% Nejprve uvedeme tridu dokumentu s volbami
\documentclass[ing,male,java,dept460]{diploma}						% jednostranny dokument
%\documentclass[ing,male,java,dept460,twoside]{diploma}		% oboustranny dokument
\usepackage[czech]{babel}

% JavaScript highlighting
\usepackage{listings}
\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{JavaScript}{
	keywords=keywords={break, case, catch, continue, debugger, default, delete, do, else, finally, for, function, if, in, instanceof, new, return, switch, this, throw, try, typeof, var, void, while, with},
	keywordstyle=\color{blue}\bfseries,
	ndkeywords={class, export, boolean, throw, implements, import, this},
	ndkeywordstyle=\color{darkgray}\bfseries,
	identifierstyle=\color{black},
	sensitive=false,
	comment=[l]{//},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{purple}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	morestring=[b]',
	morestring=[b]"
}

\lstset{
	 language=JavaScript,
	 extendedchars=true,
	 basicstyle=\footnotesize\ttfamily,
	 showstringspaces=false,
	 showspaces=false,
	 numbers=left,
	 numberstyle=\footnotesize,
	 numbersep=9pt,
	 tabsize=2,
	 breaklines=true,
	 showtabs=false,
	 captionpos=b
}

% Zadame pozadovane vstupy pro generovani titulnich stran.
\ThesisAuthor{Ondřej Ždych}
% U bakalarske praxe neni nutne nazev zadavat
\ThesisTitle{Hlasový portál na platformě VoiceXML}

% U bakalarske praxe neni nutne anglicky nazev zadavat
\EnglishThesisTitle{Voice Portal with VoiceXML Platform}

\SubmissionDate{7. května 2014}

\PrintPublicationAgreement{false}

\Thanks{Touto cestou bych rád poděkoval vedoucímu diplomové práce, panu Ing. Pavlovi Nevludovi, především za konzultace a odborné rady, které jsem zúročil při psaní tohoto textu.}

\CzechAbstract{Tohle je nějaký abstrakt. Tohle je nějaký abstrakt. Tohle je nějaký abstrakt. Tohle je nějaký abstrakt.
Tohle je nějaký abstrakt. Tohle je nějaký abstrakt. Tohle je nějaký abstrakt. Tohle je nějaký abstrakt.
Tohle je nějaký abstrakt. Tohle je nějaký abstrakt. Tohle je nějaký abstrakt. Tohle je nějaký abstrakt.}

\CzechKeywords{VoiceXML, VXML, hlasový portál, XML, JSON, ASR, TTS, JavaScript, Node.js, AngularJS}

\EnglishAbstract{This is English abstract. This is English abstract. This is English abstract. This is English abstract. This is English abstract. This is English abstract.}

\EnglishKeywords{VoiceXML, VXML, voice portal, XML, JSON, ASR, TTS, JavaScript, Node.js, AngularJS}

% Pridame pouzivane zkratky (pokud nejake pouzivame).
\AddAcronym{HTTP}{Hypertext Transfer Protocol}
\AddAcronym{SAP}{Single Page Application}
\AddAcronym{HTML}{Hypertext Markup Language}
\AddAcronym{AJAX}{Asynchronous JavaScript and XML}
\AddAcronym{JSON}{JavaScript Object Notation}
\AddAcronym{XML}{Extensible Markup Language}
\AddAcronym{REST}{Representational State Transfer}
\AddAcronym{API}{Application Programming Interface}
\AddAcronym{URL}{Uniform Resource Locator}
\AddAcronym{TCP}{Transmission Control Protocol}
\AddAcronym{PDF}{Portable Document Format}
\AddAcronym{ASR}{Automatic Speech Recognition}
\AddAcronym{TTS}{Text To Speech}
\AddAcronym{DTMF}{Dual-tone multi-frequency signaling}
\AddAcronym{IVR}{Interactive Voice Response}


% Zadame cestu a jmeno souboru ci nekolika souboru s digitalizovanou podobou zadani prace
% Pri sazbe se pak hledaji soubory Figures/Zadani1.jpg, Figures/Zadani2.jpg atd.
% Do diplomove prace se postupne vlozi vsechny existujici soubory Figures/ZadaniXXX.jpg
% Pokud toto makro zapoznamkujeme sazi se stranka s upozornenim
\ThesisAssignmentImagePath{Figures/Zadani}

% Zadame soubor s digitalizovanou podobou prohlaseni
% Pokud toto makro zapoznamkujeme sazi se cisty text prohlaseni
%\DeclarationImageFile{Figures/Prohlaseni.jpg}


% Zacatek dokumentu
\begin{document}

% Nechame vysazet titulni strany.
\MakeTitlePages

% Asi urcite budeme potrebovat obsah prace.
\tableofcontents
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve

% Jsou v praci tabulky? Pokud ano vysazime jejich seznam.
% Pokud ne smazeme nasledujici makro.
\listoftables
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve

% Jsou v praci obrazky? Pokud ano vysazime jejich seznam.
\listoffigures
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve


% Jsou v praci vypisy programu? Pokud ano vysazime jejich seznam.
\lstlistoflistings
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve



% Zacneme uvodem
\section{Úvod}
\label{sec:Uvod}
Tady bude super úvod.

\section{Seznámení s problematikou VoiceXML}
\label{sec:Seznameni_s_vxml}
Něco o standardu VXML.

\subsection{Vývoj standardu}
Něco z historie.

\subsubsection{Verze 1.0}
Popis verze 1.

\subsubsection{Verze 2.0 a 2.1}
Popis verze 2.0 a 2.1.

\subsubsection{Budoucnost VXML}
Popis draftu 3.0.

\subsection{Základy VXML}
\label{sec:Zaklady_vxml}
Základní info.

\subsubsection{Struktura VXML dokumentu}
Popis typické struktury VXML dokumentu. Členění aplikace do formu. Komunikace se serverem. (form, field)

\subsubsection{Uživatelský vstup}
Jak funguje zpracování vstupu od uřivatele. Popis gramatik a tagu, ktere se vztahuji ke sberu vstupu.

\subsubsection{Uživatelský výstup}
Popis možností generování výstupů pro uživatele. Tagy.

\subsection{Interpretry VXML}
Přehled vybraných interpretrů.

\subsubsection{Voxeo Prophecy}
Něco o Voxeu - licence, omezení, výhody (kvalitní TTS, podpora ASR), nevýhody (komerční).

\subsubsection{Asterisk + VoiceGlue}
Popis kombinace Asterisku a VoiceGlue - licence, omezení, výhody (opensource), nevýhody (nekvalitní TTS, nepodporuje ASR).

\section{Technologie Text to Speech}
\label{sec:TTS}
Obecný úvod o technologiích TTS. Popis procesu syntézy řeči.

\subsection{Flite}
Něco o Flite.

\subsection{Cepstral}
Něco o Cepstralu?

\subsection{Loquendo}
Něco o Loquendu.

\section{Technologie Automatic Speech Recognition}
\label{sec:ASR}
Popis procesu převodu řeči na text.

\subsection{Loquendo}
Něco o ASR od Loquenda.

\section{Návrh webového portálu}
\label{sec:Navrh}
Na začátku této kapitoly nejprve představím aplikaci, která bude ve zbytku textu sloužit jako referenční aplikace. Na této aplikaci budu poté ve zbývajícím textu kapitoly demonstrovat proces návrhu a následnou implementaci.

Jako referenční aplikaci jsem zvolil rezervační systém smyšlené letecké společnosti. Rezervační systém obsahuje webové a hlasové rozhraní pro správu rezervací letů. Rezervace lze tedy spravovat z prostředí webového prohlížeče nebo z prostředí samoobslužné hlasové linky.

Pro práci s rezervačním systémem je nutné se nejdříve přihlásit. Každý přihlašovaný uživatel se prokazuje přihlašovacím jménem (telefonní číslo) a heslem. Do systému se můžou přihlásit dva typy uživatelů. V závislosti na roli přihlášeného uživatele jsou uživateli dovoleny akce, které může vykonávat. Prvním typem uživatele je uživatel v roli zákazníka. Zákazníkovi je dovoleno vytvoření nové rezervace nebo zrušení již aktivní rezervace, dále je zákazníkovi umožněno vyhledávání letů dle následujících kritérií:

\begin{itemize}
\item místa a data odletu
\item místa a data příletu
\item ceny letu
\item maximálního počtu přestupů
\item maximální délky letu
\end{itemize}

Druhým typem uživatele je uživatel v roli administrátora. Pro uživatele s právy administrátora jsou dostupné stejné akce jako uživateli v roli zákazníka, navíc však administrátor může vykonávat následující akce:

\begin{itemize}
\item přihlášení/odhlášení ze systému
\item správa databáze letů (editace/vytvoření)
\item správa uživatelů (editace/vytvoření)
\item správa přepravních společností (editace/vytvoření)
\end{itemize}

Webové rozhraní rezervačního systému je v reálném čase synchronizováno s hlasovým rozhraním pomocí technologie WebSockets\footnote{Webová technologie umožňující vytvoření obousměrného komunikačního kanálu mezi klientem a serverem nad HTTP protokolem. Více informací o této technologii najdete v kapitole \ref{sec:Pouzite_technologie}.} Toto v praxi znamená následující. Pokud je uživatel přihlášen do webového rozhraní a zároveň se nachází v interakci s hlasovou samoobsluhou, kde např. zruší svoji rezervaci, okamžitě dojde k reflektování provedené akce do webového rozhraní aniž by uživatel musel znovu provést načtení zobrazené stránky.

Webové rozhraní rezervačního systému nabízí uživateli pohodlné grafické rozhraní pro správu rezervací. Webová aplikace je navržena jako jednostránková aplikace\footnote{Moderní způsob návrhu webové aplikace, kdy je aplikace reprezentována jednou základní HTML stránkou (statickou) a veškeré další interakce na stránce jsou řešeny pomocí JavaScriptu.}. Tento způsob návrhu aplikace uživateli přináší rychlejší odezvu uživatelského rozhraní a zároveň minimalizuje množství přenesených dat po síti mezi klientem a serverem. Úspory přenesených dat se dosahuje využitím AJAXového načítání dat, kdy dochází k načtení pouze těch dat, která jsou aktuálně potřebná.

V aplikaci je implementované REST API\footnote{Architektura rozhraní navržená pro distribuované prostředí. REST je, na rozdíl od známějších XML-RPC či SOAP, orientován datově, nikoli procedurálně.}, které slouží jako datový zdroj pro klienty. REST API implementuje přístup k datům, která jsou uložena v databázi. Většina metod REST API generuje notifikace pro ostatní připojené klienty. Notifikace slouží k synchronizaci uživatelských rozhraní všech připojených klientů.

Data se mezi klientem a serverovou částí aplikace (RESP API) přenáší ve formátu JSON. Formát JSON preferuji hlavně z toho důvodu, že pro zakódování informace je potřeba menšího objemu dat než např. ve srovnání s formátem XML. Implementace REST API však volitelně dovoluje použít pro komunikaci např. i formát XML. Stačí jen o tom do požadavku přidat informaci. Možnost zvolit si formát přenášených dat je umožněna díky malé knihovně, která vznikla zároveň s touto prací. Tato knihovna řeší univerzálním způsobem převod jakéhokoliv JSON objektu do XML formátu. V tabulce č. \ref{tab:RestAPI} se nachází popis implementovaných metod REST API. API běží na základní URL adrese $/api/v1/$\footnote{URL zdroje pro získání informací o jednom letu tedy vypadá následovně http://muj.server.cz/api/v1/fligths/1.} a to z toho důvodu, aby bylo možné jednotlivé verze API v budoucnosti případně verzovat.

\begin{table}
	\centering
	\begin{tabular}{|c|l|p{6cm}|}
		\hline
		HTTP metoda & URL adresa & Popis metody \\
		\hline
		GET & /flights & Vrací stránkovaný seznam (vyfiltrovaných) letů. \\
		\hline
		GET & /flights/\{id\} & Vrací informace o letu. \\
		\hline
		GET & /flights/\{id\}/make-reservation & Provádí rezervaci letu pro právě přihlášeného uživatele. \\
		\hline
		GET & /flights/\{id\}/cancel-reservation & Ruší rezervaci letu pro právě přihlášeného uživatele. \\
		\hline
		POST & /flights & Zakládá nový let. \\
		\hline
		DELETE & /flights/\{id\} & Odstraňuje let. \\
		\hline
		PUT & /flights/\{id\} & Aktualizuje informace o letu. \\


		\hline
		GET & /users & Vrací stránkovaný seznam uživatelů. \\
		\hline
		GET & /users/\{id\} & Vrací informace o uživateli. \\
		\hline
		GET & /users/\{id\}/list-reservations & Vrací seznam rezervací pro daného uživatele. \\
		\hline
		GET & /users/check-login?login=\{login\} & Zjišťuje, zda dané uživatelské jméno již existuje. \\
		\hline
		POST & /users & Zakládá nového uživatele. \\
		\hline
		DELETE & /users/\{id\} & Odstraňuje uživatele. \\
		\hline
		PUT & /users/\{id\} & Aktualizuje informace o uživateli. \\

		\hline
		GET & /carriers & Vrací stránkovaný seznam přepravců. \\
		\hline
		GET & /carriers/\{id\} & Vrací informaci o přepravci. \\
		\hline
		POST & /carriers & Zakládá nového přepravce. \\
		\hline
		DELETE & /carriers/\{id\} & Odstraňuje přepravce. \\
		\hline
		PUT & /carriers/\{id\} & Aktualizuje informace o přepravci. \\

		\hline
		GET & /destinations?q=\{destination\} & Vrací seznam vyfiltrovaných destinací. Metoda slouží pro našeptávač. \\

		\hline
		POST & /security/login & Přihlašuje uživatele. \\
		\hline
		POST & /security/logout & Odhlašuje uživatele. \\
		\hline
		GET & /security/current-user & Vrací data o aktuálně přihlášeném uživateli. \\
		\hline
	\end{tabular}
	\caption{Přehled implementovaných metod REST API}
	\label{tab:RestAPI}
\end{table}

\subsection{Uživatelské rozhraní}
Rozhraní aplikace je rozděleno do několika stránek. Po přihlášení do aplikace je zobrazena hlavní stránka se seznamem všech letů \ref{fig:FlightList}. Jednotlivé lety jsou zde zobrazeny v seznamu, který je stránkovatelný a je zde možnost nastavení počtu zobrazených položek na stránce. Každý řádek v seznamu reprezentuje jeden let. U každého letu jsou uvedeny základní informace. Na konci každého řádku se nachází tlačítka sloužící pro vytvoření nebo zrušení rezervace letu. Řádek, který představuje rezervovaný let je graficky odlišen jinou barvou pozadí. Dále je zde k dispozici tlačítko pro zobrazení detailních informací o letu. Pokud je přihlášen uživatel s právy administrátora, tak má možnost informace o letu i upravovat. Posledním tlačítko slouží ke smazání letu s databáze. Toto tlačítko se opět zobrazuje jen v případě, že je přihlášen uživatel s právy administrátora.

\InsertFigure{Figures/web_flight_list}{1\textwidth}{Stránka zobrazující seznamem letů a filtr}{fig:FlightList}

Nad seznamem letů se nachází formulář pro nastavení vyhledávacích kritérií, dle kterých lze poté seznam letů vyfiltrovat.

V horní části stránky se nachází menu, které je viditelné ze všech stránek webového rozhraní. Menu obsahuje odkazy na další stránky aplikace jako je stránka se seznamem uživatelů a stránka se seznamem přepravců. V pravé části horního menu se nachází informace se jménem aktuálně přihlášeného uživatele s tlačítkem, které slouží k odhlášení uživatele.

Ostatní stránky aplikace mají uživatelské rozhraní uspořádané obdobně. Odkazy z horního menu vždy vedou na stránky se seznamovým zobrazením dané entity (lety, uživatelé, přepravci). Z toho seznamu existuje možnost přechodu na detail konkrétní entity. V závislosti na právech přihlášeného uživatele je zde možné entitu případně editovat. Pro ukázku uvádím ještě obrázek zobrazující formulář pro editaci letu\ref{fig:FlightDetail}.

\InsertFigure{Figures/web_flight_detail}{1\textwidth}{Stránka zobrazující formulář pro editaci letu}{fig:FlightDetail}

\subsection{Použité technologie}
\label{sec:Pouzite_technologie}
Celá webová aplikace je napsána kompletně v JavaScriptu a to včetně serverové části. V následujících odstavcích stručně popíši použité technologie a důvod jejich použití.

\subsubsection{JavaScript}
\label{sec:JavaScript}
Je multiparadigmatický skriptovací jazyk ovlivněný hlavně jazyky Java, Perl a Smalltalk. Jedná se o událostmi řízený programovací jazyk. Od klasických programovacích jazyků se liší hlavně podporou prototypové dědičnosti a skutečností, že vše je objekt (dokonce i funkce). Tento jazyk byl vytvořen Brendanem Eichem v roce 1997. Primárním důvodem vzniku tohoto jazyka byla potřeba možnosti obohacení statických webových stránek. Jazyk prošel několika verzemi, kdy do něj byly postupně přidávány nové vlastnosti. V době psaní této práce (2014), je nejvíce rozšířená verze EcmaScript 5 a postupně se začínají do jazyka implementovat vlastnosti z nadcházející specifikace EcmaScript 6.

Díky platformě Node.js již není JavaScript omezen jen na oblast klientského skriptování, ale pronikl i na stranu serverového programování a umožňuje návrh vysoce škálovatelných síťových aplikací.

\subsubsection{AngularJS}
AngularJS je framework, který svými unikátními vlastnostmi ulehčuje návrh jednostránkových aplikací v JavaScriptu. Mezi klíčové vlastnosti frameworku patří obousměrný databinding, neboli automatické provázání dat (modelu) s vizuální reprezentací (pohledem). Další užitečnou vlastností Angularu je šablonovací systém, který pomocí direktiv umožňuje rozšířit standardní sadu HTML tagů o nové specifické HTML tagy. Více informací o této technologii najdete v dokumentaci frameworku\cite{angulardocs}.

Tento framework jsem použil k návrhu klientské části aplikace a to právě z výše uvedených důvodů.

\subsubsection{Node.js}
Node.js\cite{nodejs} je technologie přinášející možnost psát serverové části webových aplikací v JavaScriptu. Platforma Node.js se skládá z běhového prostředí, které je postaveno nad JavaScript enginem V8\footnote{Stejný engine je i součástí webového prohlížeče Chromium.} a knihovnou funkcí. Mezi důležité vlastnosti Node.js patří jeho asynchronní, událostmi řízená povaha, tedy veškeré vstupně/výstupní operace jsou zpracovávány asynchronně. Díky tomuto chování v praxi dochází k tomu, že webový server postavený nad Node.js dokáže zpracovat více souběžných požadavků\footnote{Za předpokladu, že je aplikace orientovaná na vstupně/výstupní operace jako je např. čtení z databáze nebo ze souborového systému.}.

Technologii jsem zvolil hlavně proto, že mi umožňuje psát serverovou a klientskou část aplikace ve stejném programovacím jazyce, tedy v JavaScriptu.

\subsubsection{Express.js}
\label{sec:ExpressJs}
Jedná se o minimalistický framework pro Node.js, který umožňuje snadné vytváření webových aplikací. Nabízí např. funkce pro práci s cookies, práci s objektem příchozího požadavku a zápis do objektu odpovědi. Framework je jednoduše rozšiřitelný o další funkce.

Více informací o tomto frameworku je možné nalézt na oficiálním webu\cite{expressjs}.

\subsubsection{MongoDB}
Pro ukládání dat jsem zvolil databázi MongoDB. MongoDB je NoSQL databáze, což znamená, že principy přístupu k datům nejsou implementovány na bázi relací jako jsme zvyklí u klasických relačních databází. MongoDB se řadí mezi dokumentové databáze, které nemají pevně definované schéma. Více informací o MongoDB databázi lze nalézt na webu projektu\cite{mongodb}.

V kombinaci s touto databází jsem použil nadstavbu Mongoose\cite{mongoose}, což je vrstva přidávající možnost nadefinovat si pevné schéma dokumentů a pracovat s těmito dokumenty jako s datovými modely. Tato vrstva dále umožňuje např. přidávání validačních metod na jednotlivé modely.

\subsubsection{WebSockets}
\label{sec:WebSockets}
Je technologie pro tvorbu webových aplikací, které mezi sebou potřebují komunikovat v reálném čase. Technologie je součástí standardu HTML5 a je již v moderních prohlížečích plně implementována. Technologie umožňuje vybudovat plně duplexní komunikační kanál mezi klientem serverem a tímto kanálem si vzájemně vyměňovat data. Jedná se v podstatě o obdobu klasického TCP spojení přeneseného do oblasti webových aplikací. WebSockety komunikují nad standardním HTTP protokolem, nemají proto problém s jakýmikoliv proxy servery a firewally na trase mezi klientem a serverem.

Tuto technologii v aplikaci používám k synchronizaci všech aktuálně otevřených webových rozhraní, aby přihlášený uživatel nemusel otevřenou stránku ve webovém prohlížeči manuálně znovu načítat.

\subsubsection{Grunt}
Jedná se o automatizační nástroj, který usnadňuje workflow vývoje (nejen) webových aplikací. Tento nástroj nabízí aplikační rozhraní pro definici úkolů, které se mají automaticky provést v definovaný moment. Definice úkolů se popisuje v jazyce JavaScript. Já jsem tento nástroj použil např. k validaci zdrojového kódu napsaného v JavaScriptu nebo ke spouštění webového serveru. Tento nástroj jsem dokonce využil k automatizaci sazby této práce - po každém uložení zdrojového \LaTeX\ souboru dojde k automatickému vytvoření výstupního PDF souboru. Více informaci o tomto nástroji je možné nalézt na oficiálních webových stránkách\cite{grunt}.

\section{Návrh hlasového portálu}
\label{sec:Navrh_hlasoveho_portalu}
V této části práce se zaměřím na popis procesu návrhu a následné implementace hlasového portálu rezervačního systému. Rezervační systém byl podrobněji představen za začátku kapitoly \ref{sec:Navrh}. Hlasový portál umožňuje uživateli spravovat své rezervace prostřednictvím hlasové samoobsluhy, se kterou se spojí vytočením telefonního čísla např. na svém mobilním telefonu.

Hlasový portál se od portálu webového liší hlavně ve způsobu interakce uživatele se systémem a množinou dostupných akcí, které jsou uživateli umožněny. Stručně řečeno je uživateli nabídnuta podmnožina akcí, které jsou dostupné ve webovém portálu. Hlasový portál nabízí užší množinu funkcí hlavně z toho důvodu, že ne všechny funkce systému lze z pohledu uživatelského rozhraní komfortně implementovat i v prostředí hlasového systému. Hlasový portál je tedy cílen pouze na uživatele v roli zákazníka letecké společnosti a nenabízí funkce uživatelům v roli administrátora systému, které jim jsou dostupné prostřednictvím webového portálu (např. přidání nového letu do databáze).

V následujícím seznamu uvádím souhrn akcí, které může uživatel prostřednictvím hlasového portálu vykonávat:

\begin{itemize}
\item přihlášení do systému
\item založení nové rezervace
\item vylistování seznamu aktivních rezervací
\item zrušení všech aktivních rezervací
\item odhlášení ze systému
\end{itemize}

V následujícím textu nejdříve popíši odlišnosti v návrhu uživatelského rozhraní hlasového portálu ve srovnání s návrhem uživatelského rozhraní webového portálu a poté se zaměřím na samotnou implementaci hlasového rozhraní rezervačního systému.

\subsection{Uživatelské rozhraní}
Rozhraní sloužící ke komunikaci mezi uživatelem a hlasovým portálem je diametrálně odlišné od rozhraní, které nabízí webové portály. Proto je nutné při návrhu uživatelského rozhraní hlasového portálu k těmto odlišnostem přihlédnout. Hlavní rozdíl mezi uživatelským rozhraním webových a hlasových portálů je ve způsobu interakce. Zatímco webové portály nabízí uživatelská rozhraní založená převážně na interakci pomocí vizuálních vjemů uživatele, při návrhu uživatelského rozhraní hlasového portálu není možné interakci založenou na vizuálních vjemech aplikovat. Uživatelské rozhraní hlasových portálů je totiž založeno pouze na zvukových vjemech a hlasových odezvách. Proto není vhodné navrhovat příliš komplexní uživatelské rozhraní. Naopak, musíme se snažit uživatelské rozhraní členit co nejjednodušeji a přehledně tak, abychom uživateli interakci se systémem co nejvíce zjednodušili a nedocházelo tak k dezorientaci v prostředí systému.

Komunikace s uživatelem většinou probíhá pomocí automatické syntézy řeči. Zatím však neexistuje hlasový syntetizátor, který by se svou kvalitou zcela vyrovnal lidské řeči. V závislosti na kvalitě použitého syntetizéru může někdy při syntéze řeči docházet ke komolení slov a pro uživatele nemusí být sdělení zcela srozumitelné. V tomto případě většinou stačí nahradit zkomolenou část věty jiným slovem či slovním spojením. V případě použití nekvalitního syntetizéru řeči se, před nasazením hlasového portálu do produkčního prostředí, doporučuje veškerá hlasová sdělení namluvit a zdigitalizovat a tyto nahrávky používat místo automatické syntézy.

Před začátkem návrhu uživatelského rozhraní hlasového systému je vhodné nejdříve provést analýzu cílové skupiny uživatelů, která bude daný systém používat. Uživatelé z různých cílových skupin mají ve většině případů odlišné požadavky na podobu uživatelského rozhraní. Pokud se například zaměřujeme na skupinu uživatelů staršího věku, můžeme předpokládat, že tito uživatelé nemají žádné nebo velmi omezené zkušenosti s ovládáním hlasového portálu. Proto bychom se měli snažit ovládání systému ještě více zjednodušit. Takového zjednodušení lze dosáhnout například nabídnutím možnosti vyvolání okamžité nápovědy během právě probíhající hlasového interakce. Pro takového uživatele bude zároveň jistě pohodlnější komunikovat se systémem za pomoci automatického rozpoznávání řeči než pomocí DTMF volby.

Naopak pokud víme, že naši aplikaci budou využívat převážně uživatelé, kteří jsou znalí moderních technologií, můžeme si dovolit navrhnout složitější uživatelské rozhraní založené na ovládání pomocí DTMF volby.

Jedno je ale společné pro všechny typy uživatelů. Za každých okolností jim musíme umožnit rychlou a pohodlnou navigaci napříč celou aplikací tak, aby byli schopni se v co nejkratším čase dostat k informaci, kterou hledají.

Já jsem se při návrhu hlasového portálu zaměřil na cílovou skupinu uživatelů, u kterých již předpokládám určitou znalost komunikace s hlasovým portálem\footnote{Předpokládám tedy, že uživatelé mají zkušenost alespoň s hlasovou samoobsluhou svého mobilního operátora}. Pro navigaci napříč hlasovým portálem se využívá ovládání pomocí DTMF volby. Ovládání pomocí DTMF volby jsem zvolil hlavně ze dvou důvodů. Prvním důvodem je potřeba získávat od uživatele přesné vstupy jako je např. zadání data nebo identifikátoru rezervace letu. Tyto vstupy se dají jednoduše zadávat pomocí DTMF volby. Dalším důvodem zvolení DTMF je široká podpora tohoto typu vstupu ze strany IVR platforem. Mým cílem bylo zprovoznit aplikaci na dvou různých IVR platformách, přičemž jedna z nich nenabízí podporu vstupu pomocí automatického rozpoznávání řeči. V rámci zachování jednotné metody vstupu napříč všemi testovanými IVR platformami jsem tedy zvolil DTMF volbu.

Aby bylo možné s hlasovým rozhraním rezervačního systému začít pracovat, je nutné se do něj nejdříve přihlásit. Každý uživatel se prokazuje svým telefonním číslem a číselným heslem. Pokud uživatel zadá špatné telefonní číslo a heslo, tak je mu nabídnuto opakované zadání. V případě, že se uživatel prokáže správným telefonním číslem, ale špatným heslem a toto zadání provede třikrát za sebou špatně, tak dojde k dočasnému zablokování toho účtu. V tomto případě je uživateli sdělena informace o tom, kdy se může zkusit znovu přihlásit.

\InsertFigure{Figures/diagrams/mainflow}{1\textwidth}{Diagram popisující hlavní strukturu hlasového portálu}{fig:MainFlow}

V případě úspěšného přihlášení do systému, je uživateli přehrána uvítací zpráva a následně je uživatel přesměrován do hlavního menu aplikace, kde má k dispozici akce pro správu a vytváření rezervací (seznam akcí je uveden v textu kapitoly \ref{sec:Navrh_hlasoveho_portalu}). Jednotlivá menu aplikace jsou navržena tak, aby měl uživatel kdykoliv možnost vrátit se o úroveň zpět. Na obrázku \ref{fig:MainFlow} je zobrazena hlavní struktura hlasového portálu. Struktura aplikace je na obrázku popsána formou stavového diagramu. Obdélníky reprezentují jednotlivé stavy aplikace. Některé stavy jsou pro svoji komplexnost zobrazeny pouze abstraktně. U abstraktních stavů je vždy uvedena informace, která slouží jako jakýsi odkaz na další diagram, který daný stav popisuje detailněji. Jako příklad můžu uvést stav pojmenovaný $getLoginData$. U tohoto stavu je ve dvojitých úhlových závorkách uvedena informace $<<GetLoginDataFlow>>$. Tato informace nám říká, že stav $getLoginData$ obsahuje další vnořené stavy. Tyto stavy jsou v aplikaci implementovány třídou $GetLoginDataFlow$. K této třídě existuje diagram, který popisuje vnitřní uspořádání těchto stavů a přechody mezi nimi. Pro ukázku uvádím ještě diagram této třídy na obrázku \ref{fig:GetLoginDataFlow}.

\InsertFigure{Figures/diagrams/getlogindataflow}{0.8\textwidth}{Diagram popisující vnitřní stavy stavu $getLoginData$ (GetLoginDataFlow)}{fig:GetLoginDataFlow}

Pomocí šipek jsou v diagramu popsány přechody mezi jednotlivými stavy. U každého přechodu se dále nachází informace identifikující daný přechod. Součástí této informace může být i doplňující informace o DTMF volbě, která slouží jako parametr tohoto přechodu a bývá uvedena v hranatých závorkách.

Z důvodu zpřehlednění textu zde neuvádím diagramy všech částí aplikace. Nejvíce zajímavým částem aplikace se budu detailněji věnovat později.

\subsection{Implementace hlasového portálu}
V této kapitole se budu věnovat implementaci hlasového portálu. Nejdříve se zaměřím na popis knihovny, která vznikla v rámci této práce za účelem usnadnění vývoje hlasových portálů postavených na platformě VoiceXML. Poté se vrátím k detailnějšímu popisu implementace vybraných částí hlasového portálu.

Proces implementace hlasového portálu můžu tedy rozdělit na dvě části. První částí je návrh VXML knihovny a druhou částí je návrh hlasového portálu rezervačního systému s využitím vytvořené knihovny.

\subsubsection{Implementace pomocné knihovny}

V kapitole \ref{sec:Zaklady_vxml} jsme se seznámili se základy návrhu VoiceXML dokumentů, konkrétně jsme se zde zaměřili na strukturu VXML dokumentu a popis vybraných elementů, které slouží k definici struktury aplikace. Již tedy máme dispozici znalosti, díky kterým jsme schopni napsat VXML kód, který popisuje jednoduchý hlasový portál.

Při návrhu složitějšího hlasového portálu by nám mohla ušetřit hodně práce vyšší úroveň abstrakce. Tato abstrakce by nás mohla odstínit od přímého psaní VMXL kódu. A právě tuto abstrakci zajišťuje knihovna, kterou jsem vyvinul v rámci této diplomové práce. Při použití této knihovny se nemusíme soustředit na psaní validního VXML kódu, ale veškeré naše soustředění můžeme zaměřit na aplikační logiku. Tato knihovna dále umožňuje dosáhnout efektivní znovu použitelnosti kódu formou komponentního modelu. V neposlední řadě knihovna zjednodušuje vývoj tím způsobem, že v podstatě ruší rozdělení aplikace na klientskou a serverovou část. Při vývoji aplikace tedy nemáme aplikaci striktně rozdělenou na statické VXML dokumenty, které definují strukturu aplikace a zajišťují vstup a výstup, a serverovou část, která řeší přístup k datům a implementuje aplikační logiku.

Knihovna je implementována v JavaScriptu\footnote{Více informací o této technologii můžete najít v kapitole \ref{sec:JavaScript}.} a aplikace, která je vyvíjena s využitím této knihovny je spouštěna v serverovém prostředí na platformě Node.js.

Samotná aplikace se dá jednoduše popsat jako kolekce stavů mezi kterými jsou definovány přechody do stavů dalších (v podstatě se tedy jedná o stavový automat). Každý stav může být určitého typu. Jedním typem je stav, sloužící k získání vstupu od uživatele. Dalším typem je stav, který zajišťuje výstup, tedy sděluje uživateli nějakou informaci. Posledním typem je stav, který nezajišťuje vstup ani výstup, ale implementuje pouze logiku, na základě které dochází mj. k rozhodnutí do jakého dalšího stavu se bude přecházet.

Každý stav může vyvolávat události. Pro každou vyvolanou událost je definován přechod do dalšího stavu. Způsob definice přechodů pomocí událostí zabraňuje vzniku pevných vazeb mezi objekty, které spolu potřebují nějakým způsobem komunikovat. V rámci interní implementace stavu tedy může docházet k vyvolání události, na které mohou závislé objekty nějakým způsobem reagovat.

Každý stav může definovat akci, která se vyvolá v momentě, kdy dojde ke vstupu do tohoto stavu. Stav zároveň může definovat akci, která se provede těsně před přechodem do nového stavu, tedy při opouštění stavu, který tuto akci definoval. U stavů, které slouží k získání vstupu uživatele se obsluha akce při opouštění stavu typicky využívá ke zpracování vstupních dat (např. zápis dat do databáze).

Každý stav se může skládat z dalších (vnořených) stavů. V případě, že stav vnořené stavy obsahuje, tak se mezi stavy přechází následujícím způsobem. Nejdříve se postupně navštíví vnořené stavy rodičovské stavu. Jakmile dojde k navštívení vnořeného stavu, který je finální, tak se zpracování vrací k přechodům, které má definován rodičovský stav.

Knihovna nám tedy poskytuje rozhraní API umožňující definovat jednotlivé stavy aplikace, přechody mezi těmito stavy a akce, které se mají vyvolávat při přechodech do dalších stavů. Nemusíme se tedy starat o ruční psaní VXML kódu, který je nutný pro zpracování VXML interpretrem. Tento kód generuje knihovna automaticky.

\subsubsection{Aplikační rozhraní knihovny}
V předchozí kapitole jsem představil pomocnou knihovnu a popsal jsem důvody, které mě vedly k její implementaci.

V této části se budu podrobně věnovat jednotlivým částem rozhraní API, které nám tato knihovna nabízí. Popíši zde jednotlivé třídy, které knihovna obsahuje. Aby bylo možné srovnat vývoj VXML hlasového portálu za pomoci této knihovny s tradičním způsobem vývoje (kdy ručně vytváříme VXML kód), nesmí chybět i ukázky použití jednotlivých částí knihovny.

Ve výpise \ref{src:MenuExample} uvádím zdrojový kód jednoduché aplikace, jejíž zdrojový kód nám v dalším textu poslouží pro detailnější rozbor. Jen pro představu zde ještě uvedu, co daná aplikace dělá. Aplikace představuje jednoduché menu. Nejdříve nás aplikace přivítá uvítací hláškou. Poté dojde k přechodu do menu, kde se dozvídáme, že můžeme pomocí volby DTMF zvolit hodnotu 1, 2 nebo 3. V závislosti na výběru poté přecházíme do stavu, ve kterém jsme informováni o tom, jakou volbu jsme provedli. Pokud zvolíme jinou hodnotu, než je povoleno (např. 4) dojde k přechodu do stavu, kde je nám řečeno, že jsme zvolili nepovolenou volbu.

\lstinputlisting[label=src:MenuExample,caption={Zdrojový kód ukázkové aplikace}]{Src/MenuExample.js}

\paragraph{Třída Application}
\label{sec:Application}
Každá aplikace je reprezentována hlavním objektem aplikace, který celou aplikaci zapouzdřuje. Instance této třídy představuje hlavní objekt aplikace. Hlavním úkolem aplikačního objektu je automatické generování VXML dokumentu, který je vždy vygenerován pro aktuální stav aplikace a slouží jako vstup pro VXML interpretr. Interpretr tento dokument zpracuje a výsledkem je dialog mezi uživatelem a hlasovým systémem.

Tato třída implementuje statickou metodu \InlCode{create}, která přijímá potřebné parametry k vytvoření aplikace. Ve výpise \ref{src:Application_create} je uvedena ukázka kódu, kterým se vytvoří instance aplikace.

\lstinputlisting[label=src:Application_create,caption={Vytvoření hlavního objektu aplikace}]{Src/Application_create.js}

Metoda \InlCode{create} přijímá jako parametr jeden objekt, který obsahuje jednotlivé parametry aplikace. Následuje popis jednotlivých parametrů.

Hodnota parametru \InlCode{server} reprezentuje instanci Express.js serveru (viz \ref{sec:ExpressJs}), nad kterým VXML aplikace poběží. Tato instance je interně využita k navěšení metod, které obsluhují jednotlivé požadavky na přechod mezi stavy aplikace (HTTP požadavky).

Parametr \InlCode{route} udává, na jaké URL bude aplikace dostupná.

Parametr \InlCode{controller} je reference na konstruktor, který se použije k vytvoření hlavního flow\footnote{V textu používám termín $flow$ pro označení instancí třídy \InlCode{CallFlow}\ref{sec:CallFlow}, které definují kolekci stavů aplikace.} aplikace.

Posledním parametrem, který není povinný, je parametr \InlCode{config}. Jedná se o objekt, pomocí kterého můžeme do aplikace protlačit jakékoliv další parametry. Tyto parametry jsou poté dostupné celé aplikaci. V příkladu je uvedeno nastavení \InlCode{io}, kterým aplikaci předávám referenci na objekt, který se stará o generování push notifikací pomocí technologie WebSockets\footnote{Technologie WebSockets byla představena v kapitole \ref{sec:WebSockets}.}.

\paragraph{Třída CallFlow}
\label{sec:CallFlow}
Tato třída slouží jako bázová třída pro implementaci objektu, který představuje kontejner pro jednotlivé stavy. Primárním úkolem této třídy je vytvořit a zaregistrovat jednotlivé stavy (viz \ref{sec:State}) pomocí metody \InlCode{addState} resp. pomocí metody \InlCode{addStates}, která registruje více stavů v jednom volání.

Flow zároveň slouží jako jakási sdílená sběrnice, která je přístupná všem stavům, které jsou ve flow obsaženy. Může tedy např. sloužit k uchování dat, která jsou společná pro více stavů.

Důležitou metodou této třídy je metoda \InlCode{fireEvent(event, data)}. Tato metoda se volá v momentě, kdy je potřeba přejít do dalšího stavu. Volání přebírá dva parametry. Parametr \InlCode{event} identifikuje typ události. Na základě typu události metoda rozhodne, do jakého dalšího stavu se má přejít. Každou vyvolanou událost můžou volitelně doprovázet \InlCode{data} specifická pro danou událost.

Kód ve výpise \ref{src:MenuExample} mj. demonstruje vytvoření instance třídy \InlCode{CallFlow} a registraci stavů. Takovou instanci je možné předat hlavnímu objektu aplikace prostřednictvím hodnoty parametru \InlCode{controller} (viz \ref{sec:Application}).

\paragraph{Třída State}
\label{sec:State}
Tato třída reprezentuje jeden stav aplikace. Jedná se o bázovou třídu, ze které se dají odvodit specifičtější třídy nebo lze přímo vytvořit instanci této třídy. Jednotlivé stavy se registrují do instance třídy \InlCode{CallFlow} např pomocí metody \InlCode{addState} (viz \ref{sec:CallFlow}).

Konstruktor může přijímat tři parametry. Prvním a jediným povinným parametrem je parametr \InlCode{id}. Jedná se o identifikátor stavu, který musí být jedinečný v rámci jednoho flow.

Zbývající parametry \InlCode{target} a \InlCode{event} jsou nepovinné. V případě, že jsou tyto parametry uvedeny, tak konstruktor interně zavolá metodu \InlCode{addTransition} s hodnotami těchto parametrů. Metoda má následující předpis \InlCode{addTransition(event, target, condition)}. Tato metoda slouží k definici přechodů do dalších stavů. Každý stav může mít definováno více přechodů. Přechod je definován kombinací typu události a cílového stavu. Tato kombinace může být volitelně rozšířena ještě parametrem \InlCode{condition}. Metodě \InlCode{addTransition} může být cílový stav \InlCode{target} předán formou reference na instanci třídy \InlCode{State} nebo můžeme metodě předat pouze identifikátor stavu.

V některých případech se nám může hodit nadefinovat více přechodů se stejným typem události. Více přechodů se stejným typem události bývá typicky definováno u stavů, které nějakou formou implementují menu. V momentě, kdy je proveden výběr v menu, může být vyvolána obecná událost, např. $continue$. Tato obecná událost je parametrizována hodnotou, která byla v menu zvolena. Zde se dostáváme k volitelnému parametru \InlCode{condition}, který slouží k rozhodnutí, do jakého stavu se přejde. Hodnotou tohoto parametru je funkce, která přebírá jeden parametr a to je právě hodnota, která byla v menu zvolena. Tato funkce obsahuje rozhodovací logiku, která má tedy k dispozici informaci o vybrané hodnotě a vrací hodnotu $true$ v případě, že se má tento přechod použít pro přechod do dalšího stavu. Demonstrace toho postupu je vidět ve výpise \ref{src:MenuExample}.

Třída dále obsahuje metody \InlCode{addOnEntryAction} a \InlCode{addOnExitAction}, které slouží k registraci akcí, které se vyvolají při vstupu resp. při výstupu z tohoto stavu.

Jak již bylo předesláno dříve, každý stav může obsahovat vnořené stavy. K registraci vnořených stavů slouží metoda \InlCode{addNestedCallFlow(callFlow)}, která přijímá jeden parametr. Hodnota parametru \InlCode{callFlow} je instance, pro nás již známé, třídy \InlCode{CallFlow}, která byla popsána v kapitole \ref{sec:CallFlow}. Díky této možnosti můžeme jednoduše docílit znovupoužitelnosti kódu, kdy opakovaně využívanou komponentu implementujeme jako samostatnou třídu, která je odvozena ze třídy \InlCode{CallFlow}. Instance této třídy je poté registrována zavoláním metody \InlCode{addNestedCallFlow} na daném stavu. V případě potřeby může být tato instance parametrizována, např. předáním různých parametrů do konstruktoru.

\subsubsection{Znovupoužitelné komponenty}
Zadání data (+diagram). Zadání textového vstupu (+diagram). Seznam rezervací/letů (+diagram).

\section{Konfigurace a zprovoznění hlasového portálu}
Popis, jak zprovoznit aplikaci na platformách. Voxeo Prophecy, Asterisk + VoiceGlue.

\subsection{Voxeo Prophecy}
...

\subsection{Asterisk + VoiceGlue}
...

\section{Zátěžové testy portálu}
\label{sec:Benchmark}
Popis, jak probíhal test. Použité nástroje.

\subsection{Zátěžový test aplikačního serveru}
ab test aplikačního serveru.

\subsection{Zátěžový test IVR Voxeo Prophecy}
Omezení dva paralelní hovory. Test 1 a 2 připojených klientů.

\subsection{Zátěžový test IVR VoiceGlue}
Test 1, 2, 5, 10 pčipojených klientů.

\subsection{Výsledky měření}
Co jsme zjistili v testech?

\section{Závěr}
\label{sec:Conclusion}
Tak tady je konečně konec.
\cite{goossens94,lamport94}.

\bigskip
\begin{flushright}
Ondřej Ždych
\end{flushright}

\begin{thebibliography}{99}

\bibitem{vxmldevguide} Shukla, Charul; Dass, Avnish; Gupta, Vikas,
\textit{VoiceXML 2.0 Developer's Guide : Building Professional Voice-enabled Applications with JSP, ASP & Coldfusion}, Dream Tech Software India Inc., 2002.

\bibitem{angulardocs} Google,
\textit{Dokumentace k frameworku AngularJS}, http://docs.angularjs.org/.

\bibitem{mongodb}
\textit{Web projektu MongoDB}, http://www.mongodb.org/.

\bibitem{mongoose}
\textit{Web projektu Mongoose}, http://www.mongoosejs.com/.

\bibitem{nodejs}
\textit{Oficiální web o Node.js}, http://www.nodejs.org/.

\bibitem{expressjs}
\textit{Oficiální web o frameworku Express.js}, http://www.expressjs.com/.

\bibitem{grunt}
\textit{Oficiální web věnovaný nástroji Grunt}, http://gruntjs.com/.

\end{thebibliography}

\appendix
\section{Grafy a měření}
Tohle je příloha k práci. Většinou se sem dávají grafy, tabulky, které by vzhledem
ke svému počtu překážely v textu diplomky.
\clearpage

\end{document}
