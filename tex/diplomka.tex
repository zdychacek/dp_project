% Nejprve uvedeme tridu dokumentu s volbami
\documentclass[ing,male,java,dept460]{diploma}						% jednostranny dokument
%\documentclass[ing,male,java,dept460,twoside]{diploma}		% oboustranny dokument
\usepackage[czech]{babel}

% JavaScript highlighting
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{microtype}
\usepackage[htt]{hyphenat}
\definecolor{darkgreen}{rgb}{0, 0.5, 0}
\definecolor{maroon}{rgb}{0.5,0,0}

\lstdefinelanguage{JavaScript} {
  morekeywords={
      break,const,continue,delete,do,while,export,for,in,function,
      if,else,import,in,instanceOf,label,let,new,return,switch,this,
      throw,try,catch,typeof,var,void,with,yield
  },
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
  morestring=[d]',
  alsoletter={.},
  keywordstyle=\ttfamily\color{blue},
  identifierstyle=\ttfamily,
  stringstyle=\ttfamily\color{maroon},
  commentstyle=\color{darkgreen}\ttfamily
}

\lstdefinelanguage{XML} {
  morestring=[b]",
  moredelim=[s][\ttfamily\color{maroon}]{<}{\ },
  moredelim=[s][\ttfamily\color{maroon}]{</}{>},
  moredelim=[l][\ttfamily\color{maroon}]{/>},
  moredelim=[l][\ttfamily\color{maroon}]{>},
  morecomment=[s]{<?}{?>},
  morecomment=[s]{<!--}{-->},
  commentstyle=\color{darkgreen},
  stringstyle=\color{blue},
  identifierstyle=\color{red}
}

\lstdefinelanguage{conf} {
  morecomment=[s]{#},
  commentstyle=\color{darkgreen}
}

\lstdefinelanguage{bash} {
  keywordstyle=\color{blue}
}

\lstset {
	basicstyle=\ttfamily,
  showstringspaces=false,
  rulecolor=\color{black},
  aboveskip=\bigskipamount,
  belowskip=\bigskipamount,
  alsoletter={.},
  numbers=left,
  keywordstyle=\color{black}\ttfamily,
  breaklines=true,
  postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
}

\def\changemargin#1#2{\list{}{\topmargin#2\bottommargin#1}\item[]}
\let\endchangemargin=\endlist

% Zadame pozadovane vstupy pro generovani titulnich stran.
\ThesisAuthor{Ondřej Ždych}
% U bakalarske praxe neni nutne nazev zadavat
\ThesisTitle{Hlasový portál na platformě VoiceXML}

% U bakalarske praxe neni nutne anglicky nazev zadavat
\EnglishThesisTitle{Voice Portal with VoiceXML Platform}

\SubmissionDate{7. května 2014}

\PrintPublicationAgreement{false}

\Thanks{Touto cestou bych rád poděkoval vedoucímu diplomové práce, panu Ing. Pavlovi Nevludovi, především za konzultace a odborné rady, které jsem zúročil při psaní tohoto textu.}

\CzechAbstract{Tohle je nějaký abstrakt. Tohle je nějaký abstrakt. Tohle je nějaký abstrakt. Tohle je nějaký abstrakt.
Tohle je nějaký abstrakt. Tohle je nějaký abstrakt. Tohle je nějaký abstrakt. Tohle je nějaký abstrakt.
Tohle je nějaký abstrakt. Tohle je nějaký abstrakt. Tohle je nějaký abstrakt. Tohle je nějaký abstrakt.}

\CzechKeywords{VoiceXML, VXML, hlasový portál, XML, JSON, ASR, TTS, JavaScript, Node.js, AngularJS}

\EnglishAbstract{This is English abstract. This is English abstract. This is English abstract. This is English abstract. This is English abstract. This is English abstract.}

\EnglishKeywords{VoiceXML, VXML, voice portal, XML, JSON, ASR, TTS, JavaScript, Node.js, AngularJS}

% Pridame pouzivane zkratky (pokud nejake pouzivame).
\AddAcronym{HTTP}{Hypertext Transfer Protocol}
\AddAcronym{SAP}{Single Page Application}
\AddAcronym{HTML}{Hypertext Markup Language}
\AddAcronym{AJAX}{Asynchronous JavaScript and XML}
\AddAcronym{JSON}{JavaScript Object Notation}
\AddAcronym{XML}{Extensible Markup Language}
\AddAcronym{REST}{Representational State Transfer}
\AddAcronym{API}{Application Programming Interface}
\AddAcronym{URL}{Uniform Resource Locator}
\AddAcronym{TCP}{Transmission Control Protocol}
\AddAcronym{PDF}{Portable Document Format}
\AddAcronym{ASR}{Automatic Speech Recognition}
\AddAcronym{TTS}{Text To Speech}
\AddAcronym{DTMF}{Dual-tone multi-frequency signaling}
\AddAcronym{IVR}{Interactive Voice Response}
\AddAcronym{MIME}{Multipurpose Internet Mail Extensions}
\AddAcronym{SMS}{Short Message Service}
\AddAcronym{CLI}{Command Line Interface}
\AddAcronym{AGI}{Asterisk Gateway Interface}
\AddAcronym{SIP}{Session Initiation Protocol}
\AddAcronym{CPU}{Central Processing Unit}
\AddAcronym{IP}{Internet Protocol}
\AddAcronym{CSV}{Comma-Separated Values}

% Zadame cestu a jmeno souboru ci nekolika souboru s digitalizovanou podobou zadani prace
% Pri sazbe se pak hledaji soubory Figures/Zadani1.jpg, Figures/Zadani2.jpg atd.
% Do diplomove prace se postupne vlozi vsechny existujici soubory Figures/ZadaniXXX.jpg
% Pokud toto makro zapoznamkujeme sazi se stranka s upozornenim
\ThesisAssignmentImagePath{Figures/Zadani}

% Zadame soubor s digitalizovanou podobou prohlaseni
% Pokud toto makro zapoznamkujeme sazi se cisty text prohlaseni
%\DeclarationImageFile{Figures/Prohlaseni.jpg}


% Zacatek dokumentu
\begin{document}

% Nechame vysazet titulni strany.
\MakeTitlePages

% Asi urcite budeme potrebovat obsah prace.
\tableofcontents
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve

% Jsou v praci tabulky? Pokud ano vysazime jejich seznam.
% Pokud ne smazeme nasledujici makro.
\listoftables
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve

% Jsou v praci obrazky? Pokud ano vysazime jejich seznam.
\listoffigures
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve


% Jsou v praci vypisy programu? Pokud ano vysazime jejich seznam.
\lstlistoflistings
\cleardoublepage	% odstrankujeme, u jednostranneho dokumentu o jednu stranku, u oboustrenneho o dve



% Zacneme uvodem
\section{Úvod}
\label{sec:Uvod}
Tady bude super úvod.

\section{Seznámení s problematikou VoiceXML}
\label{sec:Seznameni_s_vxml}
Něco o standardu VXML.

\subsection{Vývoj standardu}
Něco z historie.

\subsubsection{Verze 1.0}
Popis verze 1.

\subsubsection{Verze 2.0 a 2.1}
Popis verze 2.0 a 2.1.

\subsubsection{Budoucnost VXML}
Popis draftu 3.0.

\subsection{Základy VXML}
\label{sec:Zaklady_vxml}
Základní info.

Vestavěné gramatiky

\subsubsection{Struktura VXML dokumentu}
Popis typické struktury VXML dokumentu. Členění aplikace do formu. Komunikace se serverem. (form, field)

\subsubsection{Uživatelský vstup}
Jak funguje zpracování vstupu od uřivatele. Popis gramatik a tagu, ktere se vztahuji ke sberu vstupu.

\subsubsection{Uživatelský výstup}
Popis možností generování výstupů pro uživatele. Tagy.

\subsection{Interpretry VXML}
Přehled vybraných interpretrů.

\subsubsection{Voxeo Prophecy}
\label{sec:Voxeo_interpreter}
Něco o Voxeu - licence, omezení, výhody (kvalitní TTS, podpora ASR), nevýhody (komerční).

\subsubsection{Asterisk + VoiceGlue}
Popis kombinace Asterisku a VoiceGlue - licence, omezení, výhody (opensource), nevýhody (nekvalitní TTS, nepodporuje ASR).

\section{Technologie Text to Speech}
\label{sec:TTS}
Obecný úvod o technologiích TTS. Popis procesu syntézy řeči.

\subsection{Flite}
Něco o Flite.

\subsection{Cepstral}
Něco o Cepstralu?

\subsection{Loquendo}
Něco o Loquendu.

\section{Technologie Automatic Speech Recognition}
\label{sec:ASR}
Popis procesu převodu řeči na text.

\subsection{Loquendo}
Něco o ASR od Loquenda.

\section{Návrh webového portálu}
\label{sec:Navrh}
Na začátku této kapitoly nejprve představím referenční aplikaci, na které budu poté ve zbývajícím textu kapitoly demonstrovat proces jejího návrhu a následnou implementaci.

Jako referenční aplikaci jsem zvolil rezervační systém smyšlené letecké společnosti. Rezervační systém obsahuje webové a hlasové rozhraní pro správu rezervací letů. Rezervace lze tedy spravovat z prostředí webového prohlížeče nebo z prostředí samoobslužné hlasové linky.

Pro práci s rezervačním systémem je nutné se nejdříve přihlásit. Každý přihlašovaný uživatel se prokazuje přihlašovacím jménem (telefonní číslo) a heslem. Do systému se můžou přihlásit dva typy uživatelů. V závislosti na roli přihlášeného uživatele jsou uživateli dovoleny akce, které může vykonávat. Prvním typem uživatele je uživatel v roli zákazníka. Zákazníkovi je dovoleno vytvoření nové rezervace nebo zrušení již aktivní rezervace, dále je zákazníkovi umožněno vyhledávání letů dle následujících kritérií:

\begin{itemize}
\item místa a data odletu
\item místa a data příletu
\item ceny letu
\item maximálního počtu přestupů
\item maximální délky letu
\end{itemize}

Druhým typem uživatele je uživatel v roli administrátora. Pro uživatele s právy administrátora jsou dostupné stejné akce jako uživateli v roli zákazníka, navíc však administrátor může vykonávat následující akce:

\begin{itemize}
\item přihlášení/odhlášení ze systému
\item správa databáze letů (editace/vytvoření)
\item správa uživatelů (editace/vytvoření)
\item správa přepravních společností (editace/vytvoření)
\end{itemize}

Webové rozhraní rezervačního systému je v reálném čase synchronizováno s hlasovým rozhraním pomocí technologie WebSockets\footnote{Webová technologie umožňující vytvoření obousměrného komunikačního kanálu mezi klientem a serverem nad HTTP protokolem. Více informací o této technologii najdete v kapitole \ref{sec:Pouzite_technologie}.} Toto v praxi znamená následující. Pokud je uživatel přihlášen do webového rozhraní a zároveň se nachází v interakci s hlasovou samoobsluhou, kde např. zruší svoji rezervaci, okamžitě dojde k reflektování provedené akce do webového rozhraní aniž by uživatel musel znovu provést načtení zobrazené stránky.

Webové rozhraní rezervačního systému nabízí uživateli pohodlné grafické rozhraní pro správu rezervací. Webová aplikace je navržena jako jednostránková aplikace\footnote{Moderní způsob návrhu webové aplikace, kdy je aplikace reprezentována jednou základní HTML stránkou (statickou) a veškeré další interakce na stránce jsou řešeny pomocí JavaScriptu.}. Tento způsob návrhu aplikace uživateli přináší rychlejší odezvu uživatelského rozhraní a zároveň minimalizuje množství přenesených dat po síti mezi klientem a serverem. Úspory přenesených dat se dosahuje využitím AJAXového načítání dat, kdy dochází k načtení pouze těch dat, která jsou aktuálně potřebná.

V aplikaci je implementované REST API\footnote{Architektura rozhraní navržená pro distribuované prostředí. REST je, na rozdíl od známějších XML-RPC či SOAP, orientován datově, nikoli procedurálně.}, které slouží jako datový zdroj pro klienty. REST API implementuje přístup k datům, která jsou uložena v databázi. Většina metod REST API generuje notifikace pro ostatní připojené klienty. Notifikace slouží k synchronizaci uživatelských rozhraní všech připojených klientů.

Data se mezi klientem a serverovou částí aplikace (RESP API) přenáší ve formátu JSON. Formát JSON preferuji hlavně z toho důvodu, že pro zakódování informace je potřeba menšího objemu dat než např. ve srovnání s formátem XML. Implementace REST API však volitelně dovoluje použít pro komunikaci např. i formát XML. Stačí jen o tom do požadavku přidat informaci. Možnost zvolit si formát přenášených dat je umožněna díky malé knihovně, která vznikla zároveň s touto prací. Tato knihovna řeší univerzálním způsobem převod jakéhokoliv JSON objektu do XML formátu. V tabulce \ref{tab:RestAPI} se nachází popis implementovaných metod REST API. API běží na základní URL adrese \texttt{/api/v1/}\footnote{URL zdroje pro získání informací o jednom letu tedy vypadá následovně \texttt{http://muj.server.cz/api/v1/fligths/1}.} a to z toho důvodu, aby bylo možné jednotlivé verze API v budoucnosti případně verzovat.

\begin{table}
	\centering
	\begin{tabular}{|c|l|p{6cm}|}
		\hline
		HTTP metoda & URL adresa & Popis metody \\
		\hline
		GET & /flights & Vrací stránkovaný seznam (vyfiltrovaných) letů. \\
		\hline
		GET & /flights/\{id\} & Vrací informace o letu. \\
		\hline
		GET & /flights/\{id\}/make-reservation & Provádí rezervaci letu pro právě přihlášeného uživatele. \\
		\hline
		GET & /flights/\{id\}/cancel-reservation & Ruší rezervaci letu pro právě přihlášeného uživatele. \\
		\hline
		POST & /flights & Zakládá nový let. \\
		\hline
		DELETE & /flights/\{id\} & Odstraňuje let. \\
		\hline
		PUT & /flights/\{id\} & Aktualizuje informace o letu. \\


		\hline
		GET & /users & Vrací stránkovaný seznam uživatelů. \\
		\hline
		GET & /users/\{id\} & Vrací informace o uživateli. \\
		\hline
		GET & /users/\{id\}/list-reservations & Vrací seznam rezervací pro daného uživatele. \\
		\hline
		GET & /users/check-login?login=\{login\} & Zjišťuje, zda dané uživatelské jméno již existuje. \\
		\hline
		POST & /users & Zakládá nového uživatele. \\
		\hline
		DELETE & /users/\{id\} & Odstraňuje uživatele. \\
		\hline
		PUT & /users/\{id\} & Aktualizuje informace o uživateli. \\

		\hline
		GET & /carriers & Vrací stránkovaný seznam přepravců. \\
		\hline
		GET & /carriers/\{id\} & Vrací informaci o přepravci. \\
		\hline
		POST & /carriers & Zakládá nového přepravce. \\
		\hline
		DELETE & /carriers/\{id\} & Odstraňuje přepravce. \\
		\hline
		PUT & /carriers/\{id\} & Aktualizuje informace o přepravci. \\

		\hline
		GET & /destinations?q=\{destination\} & Vrací seznam vyfiltrovaných destinací. Metoda slouží pro našeptávač. \\

		\hline
		POST & /security/login & Přihlašuje uživatele. \\
		\hline
		POST & /security/logout & Odhlašuje uživatele. \\
		\hline
		GET & /security/current-user & Vrací data o aktuálně přihlášeném uživateli. \\
		\hline
	\end{tabular}
	\caption{Přehled implementovaných metod REST API}
	\label{tab:RestAPI}
\end{table}

\subsection{Uživatelské rozhraní}
Rozhraní aplikace je rozděleno do několika stránek. Po přihlášení do aplikace je zobrazena hlavní stránka se seznamem všech letů \ref{fig:FlightList}. Jednotlivé lety jsou zde zobrazeny v seznamu, který je stránkovatelný a je zde možnost nastavení počtu zobrazených položek na stránce. Každý řádek v seznamu reprezentuje jeden let. U každého letu jsou uvedeny základní informace. Na konci každého řádku se nachází tlačítka sloužící pro vytvoření nebo zrušení rezervace letu. Řádek, který představuje rezervovaný let je graficky odlišen jinou barvou pozadí. Dále je zde k dispozici tlačítko pro zobrazení detailních informací o letu. Pokud je přihlášen uživatel s právy administrátora, tak má možnost informace o letu i upravovat. Poslední tlačítko slouží ke smazání letu z databáze. Toto tlačítko se opět zobrazuje jen v případě, že je přihlášen uživatel s právy administrátora.

\InsertFigure{Figures/web_flight_list}{1\textwidth}{Stránka zobrazující seznamem letů a filtr}{fig:FlightList}

Nad seznamem letů se nachází formulář pro nastavení vyhledávacích kritérií, dle kterých lze poté seznam letů vyfiltrovat.

V horní části stránky se nachází menu, které je viditelné ze všech stránek webového rozhraní. Menu obsahuje odkazy na další stránky aplikace jako je stránka se seznamem uživatelů a stránka se seznamem přepravců. V pravé části horního menu se nachází informace se jménem aktuálně přihlášeného uživatele s tlačítkem, které slouží k odhlášení uživatele.

Ostatní stránky aplikace mají uživatelské rozhraní uspořádané obdobně. Odkazy z horního menu vždy vedou na stránky se seznamovým zobrazením dané entity (lety, uživatelé, přepravci). Z toho seznamu existuje možnost přechodu na detail konkrétní entity. V závislosti na právech přihlášeného uživatele je zde možné entitu případně editovat. Pro ukázku uvádím ještě obrázek zobrazující formulář pro editaci letu\ref{fig:FlightDetail}.

\InsertFigure{Figures/web_flight_detail}{1\textwidth}{Stránka zobrazující formulář pro editaci letu}{fig:FlightDetail}

\subsection{Použité technologie}
\label{sec:Pouzite_technologie}
Celá webová aplikace je napsána kompletně v JavaScriptu a to včetně serverové části. V následujících odstavcích stručně popíši použité technologie a důvod jejich použití.

\subsubsection{JavaScript}
\label{sec:JavaScript}
Je multiparadigmatický skriptovací jazyk ovlivněný hlavně jazyky Java, Perl a Smalltalk. Jedná se o událostmi řízený programovací jazyk. Od klasických programovacích jazyků se liší hlavně podporou prototypové dědičnosti a skutečností, že vše je objekt (dokonce i funkce). Tento jazyk byl vytvořen Brendanem Eichem v roce 1997. Primárním důvodem vzniku tohoto jazyka byla potřeba možnosti obohacení statických webových stránek. Jazyk prošel několika verzemi, kdy do něj byly postupně přidávány nové vlastnosti. V době psaní této práce (2014), je nejvíce rozšířená verze EcmaScript 5 a postupně se začínají do jazyka implementovat vlastnosti z nadcházející specifikace EcmaScript 6.

Díky platformě Node.js již není JavaScript omezen jen na oblast klientského skriptování, ale pronikl i na stranu serverového programování a umožňuje návrh vysoce škálovatelných síťových aplikací.

\subsubsection{AngularJS}
AngularJS je framework, který svými unikátními vlastnostmi ulehčuje návrh jednostránkových aplikací v JavaScriptu. Mezi klíčové vlastnosti frameworku patří obousměrný databinding, neboli automatické provázání dat (modelu) s vizuální reprezentací (pohledem). Další užitečnou vlastností Angularu je šablonovací systém, který pomocí direktiv umožňuje rozšířit standardní sadu HTML tagů o nové specifické HTML tagy. Více informací o této technologii najdete v dokumentaci frameworku\cite{angulardocs}.

Tento framework jsem použil k návrhu klientské části aplikace a to právě z výše uvedených důvodů.

\subsubsection{Node.js}
\label{sec:NodeJs}
Node.js\cite{nodejs} je technologie přinášející možnost psát serverové části webových aplikací v JavaScriptu. Platforma Node.js se skládá z běhového prostředí, které je postaveno nad JavaScript enginem V8\footnote{Stejný engine je i součástí webového prohlížeče Chromium.} a knihovnou funkcí. Mezi důležité vlastnosti Node.js patří jeho asynchronní, událostmi řízená povaha, tedy veškeré vstupně/výstupní operace jsou zpracovávány asynchronně. Díky tomuto chování v praxi dochází k tomu, že webový server postavený nad Node.js dokáže zpracovat více souběžných požadavků\footnote{Za předpokladu, že je aplikace orientovaná na vstupně/výstupní operace jako je např. čtení z databáze nebo ze souborového systému.}.

Technologii jsem zvolil hlavně proto, že mi umožňuje psát serverovou a klientskou část aplikace ve stejném programovacím jazyce, tedy v JavaScriptu.

\subsubsection{Express.js}
\label{sec:ExpressJs}
Jedná se o minimalistický framework pro Node.js, který umožňuje snadné vytváření webových aplikací. Nabízí např. funkce pro práci s cookies, práci s objektem příchozího požadavku a zápis do objektu odpovědi. Framework je jednoduše rozšiřitelný o další funkce.

Více informací o tomto frameworku je možné nalézt na oficiálním webu\cite{expressjs}.

\subsubsection{MongoDB}
Pro ukládání dat jsem zvolil databázi MongoDB. MongoDB je NoSQL databáze, což znamená, že principy přístupu k datům nejsou implementovány na bázi relací jako jsme zvyklí u klasických relačních databází. MongoDB se řadí mezi dokumentové databáze, které nemají pevně definované schéma. Více informací o MongoDB databázi lze nalézt na webu projektu\cite{mongodb}.

V kombinaci s touto databází jsem použil nadstavbu Mongoose\cite{mongoose}, což je vrstva přidávající možnost nadefinovat si pevné schéma dokumentů a pracovat s těmito dokumenty jako s datovými modely. Tato vrstva dále umožňuje např. přidávání validačních metod na jednotlivé modely.

\subsubsection{WebSockets}
\label{sec:WebSockets}
Je technologie pro tvorbu webových aplikací, které mezi sebou potřebují komunikovat v reálném čase. Technologie je součástí standardu HTML5 a je již v moderních prohlížečích plně implementována. Technologie umožňuje vybudovat plně duplexní komunikační kanál mezi klientem serverem a tímto kanálem si vzájemně vyměňovat data. Jedná se v podstatě o obdobu klasického TCP spojení přeneseného do oblasti webových aplikací. WebSockety komunikují nad standardním HTTP protokolem, nemají proto problém s jakýmikoliv proxy servery a firewally na trase mezi klientem a serverem.

Tuto technologii v aplikaci používám k synchronizaci všech aktuálně otevřených webových rozhraní, aby přihlášený uživatel nemusel otevřenou stránku ve webovém prohlížeči manuálně znovu načítat.

\subsubsection{Grunt}
Jedná se o automatizační nástroj, který usnadňuje workflow vývoje (nejen) webových aplikací. Tento nástroj nabízí aplikační rozhraní pro definici úkolů, které se mají automaticky provést v definovaný moment. Definice úkolů se popisuje v jazyce JavaScript. Já jsem tento nástroj použil např. k validaci zdrojového kódu napsaného v JavaScriptu nebo ke spouštění webového serveru. Tento nástroj jsem dokonce využil k automatizaci sazby této práce - po každém uložení zdrojového \LaTeX\ souboru dojde k automatickému vytvoření výstupního PDF souboru. Více informaci o tomto nástroji je možné nalézt na oficiálních webových stránkách\cite{grunt}.

\subsubsection{Jade}
Jedná se o nejrozšířenější šablonovací jazyk používaný na platformě Node.js. Jade svými vlastnostmi urychluje zápis HTML kódu. Např. není potřeba psát ukončovací značky HTML elementů a není potřeba značky zapisovat v úhlových závorkách. Zanoření jednotlivých elementů je vyjádřeno postupným odsazováním elementů. Šablonovací systém je rozšiřitelný pomocí mixinů.

\section{Návrh hlasového portálu}
\label{sec:Navrh_hlasoveho_portalu}
V této části práce se zaměřím na popis procesu návrhu a následné implementace hlasového portálu rezervačního systému. Rezervační systém byl podrobněji představen za začátku kapitoly \ref{sec:Navrh}. Hlasový portál umožňuje uživateli spravovat své rezervace prostřednictvím hlasové samoobsluhy, se kterou se spojí vytočením telefonního čísla např. na svém mobilním telefonu.

Hlasový portál se od portálu webového liší hlavně ve způsobu interakce uživatele se systémem a množinou dostupných akcí, které jsou uživateli umožněny. Stručně řečeno je uživateli nabídnuta podmnožina akcí, které jsou dostupné ve webovém portálu. Hlasový portál nabízí užší množinu funkcí hlavně z toho důvodu, že ne všechny funkce systému lze z pohledu uživatelského rozhraní komfortně implementovat i v prostředí hlasového systému. Hlasový portál je tedy cílen pouze na uživatele v roli zákazníka letecké společnosti a nenabízí funkce uživatelům v roli administrátora systému, které jim jsou dostupné prostřednictvím webového portálu (např. přidání nového letu do databáze).

V následujícím seznamu uvádím souhrn akcí, které může uživatel prostřednictvím hlasového portálu vykonávat:

\begin{itemize}
\item přihlášení do systému
\item založení nové rezervace
\item vylistování seznamu aktivních rezervací
\item zrušení všech aktivních rezervací
\item odhlášení ze systému
\end{itemize}

V následujícím textu nejdříve popíši odlišnosti v návrhu uživatelského rozhraní hlasového portálu ve srovnání s návrhem uživatelského rozhraní webového portálu a poté se zaměřím na samotnou implementaci hlasového rozhraní rezervačního systému.

\subsection{Uživatelské rozhraní}
Rozhraní sloužící ke komunikaci mezi uživatelem a hlasovým portálem je diametrálně odlišné od rozhraní, které nabízí webové portály. Proto je nutné při návrhu uživatelského rozhraní hlasového portálu k těmto odlišnostem přihlédnout. Hlavní rozdíl mezi uživatelským rozhraním webových a hlasových portálů je ve způsobu interakce. Zatímco webové portály nabízí uživatelská rozhraní založená převážně na interakci pomocí vizuálních vjemů uživatele, při návrhu uživatelského rozhraní hlasového portálu není možné interakci založenou na vizuálních vjemech aplikovat. Uživatelské rozhraní hlasových portálů je totiž založeno pouze na zvukových vjemech a hlasových odezvách. Proto není vhodné navrhovat příliš komplexní uživatelské rozhraní. Naopak, musíme se snažit uživatelské rozhraní členit co nejjednodušeji a přehledně tak, abychom uživateli interakci se systémem co nejvíce zjednodušili a nedocházelo tak k dezorientaci v prostředí systému.

Komunikace s uživatelem většinou probíhá pomocí automatické syntézy řeči. Zatím však neexistuje hlasový syntetizátor, který by se svou kvalitou zcela vyrovnal lidské řeči. V závislosti na kvalitě použitého syntetizéru může někdy při syntéze řeči docházet ke komolení slov a pro uživatele nemusí být sdělení zcela srozumitelné. V tomto případě většinou stačí nahradit zkomolenou část věty jiným slovem či slovním spojením. V případě použití nekvalitního syntetizéru řeči se, před nasazením hlasového portálu do produkčního prostředí, doporučuje veškerá hlasová sdělení namluvit a zdigitalizovat a tyto nahrávky používat místo automatické syntézy.

Před začátkem návrhu uživatelského rozhraní hlasového systému je vhodné nejdříve provést analýzu cílové skupiny uživatelů, která bude daný systém používat. Uživatelé z různých cílových skupin mají ve většině případů odlišné požadavky na podobu uživatelského rozhraní. Pokud se například zaměřujeme na skupinu uživatelů staršího věku, můžeme předpokládat, že tito uživatelé nemají žádné nebo velmi omezené zkušenosti s ovládáním hlasového portálu. Proto bychom se měli snažit ovládání systému ještě více zjednodušit. Takového zjednodušení lze dosáhnout například nabídnutím možnosti vyvolání okamžité nápovědy během právě probíhající hlasového interakce. Pro takového uživatele bude zároveň jistě pohodlnější komunikovat se systémem za pomoci automatického rozpoznávání řeči než pomocí DTMF volby.

Naopak pokud víme, že naši aplikaci budou využívat převážně uživatelé, kteří jsou znalí moderních technologií, můžeme si dovolit navrhnout složitější uživatelské rozhraní založené na ovládání pomocí DTMF volby.

Jedno je ale společné pro všechny typy uživatelů. Za každých okolností jim musíme umožnit rychlou a pohodlnou navigaci napříč celou aplikací tak, aby byli schopni se v co nejkratším čase dostat k informaci, kterou hledají.

Já jsem se při návrhu hlasového portálu zaměřil na cílovou skupinu uživatelů, u kterých již předpokládám určitou znalost komunikace s hlasovým portálem\footnote{Předpokládám tedy, že uživatelé mají zkušenost alespoň s hlasovou samoobsluhou svého mobilního operátora}. Pro navigaci napříč hlasovým portálem se využívá ovládání pomocí DTMF volby. Ovládání pomocí DTMF volby jsem zvolil hlavně ze dvou důvodů. Prvním důvodem je potřeba získávat od uživatele přesné vstupy jako je např. zadání data nebo identifikátoru rezervace letu. Tyto vstupy se dají jednoduše zadávat pomocí DTMF volby. Dalším důvodem zvolení DTMF je široká podpora tohoto typu vstupu ze strany IVR platforem. Mým cílem bylo zprovoznit aplikaci na dvou různých IVR platformách, přičemž jedna z nich nenabízí podporu vstupu pomocí automatického rozpoznávání řeči. V rámci zachování jednotné metody vstupu napříč všemi testovanými IVR platformami jsem tedy zvolil DTMF volbu.

Aby bylo možné s hlasovým rozhraním rezervačního systému začít pracovat, je nutné se do něj nejdříve přihlásit. Každý uživatel se prokazuje svým telefonním číslem a číselným heslem. Pokud uživatel zadá špatné telefonní číslo a heslo, tak je mu nabídnuto opakované zadání. V případě, že se uživatel prokáže správným telefonním číslem, ale špatným heslem a toto zadání provede třikrát za sebou špatně, tak dojde k dočasnému zablokování toho účtu. V tomto případě je uživateli sdělena informace o tom, kdy se může zkusit znovu přihlásit.

\InsertFigure{Figures/diagrams/mainflow}{1\textwidth}{Diagram popisující hlavní strukturu hlasového portálu}{fig:MainFlow}

V případě úspěšného přihlášení do systému, je uživateli přehrána uvítací zpráva a následně je uživatel přesměrován do hlavního menu aplikace, kde má k dispozici akce pro správu a vytváření rezervací (seznam akcí je uveden v textu kapitoly \ref{sec:Navrh_hlasoveho_portalu}). Jednotlivá menu aplikace jsou navržena tak, aby měl uživatel kdykoliv možnost vrátit se o úroveň zpět. Na obrázku \ref{fig:MainFlow} je zobrazena hlavní struktura hlasového portálu. Struktura aplikace je na obrázku popsána formou stavového diagramu. Obdélníky reprezentují jednotlivé stavy aplikace. Některé stavy jsou pro svoji komplexnost zobrazeny pouze abstraktně. U abstraktních stavů je vždy uvedena informace, která slouží jako jakýsi odkaz na další diagram, který daný stav popisuje detailněji. Jako příklad můžu uvést stav pojmenovaný $getLoginData$. U tohoto stavu je ve dvojitých úhlových závorkách uvedena informace $<<GetLoginDataFlow>>$. Tato informace nám říká, že stav $getLoginData$ obsahuje další vnořené stavy. Tyto stavy jsou v aplikaci implementovány třídou $GetLoginDataFlow$. K této třídě existuje diagram, který popisuje vnitřní uspořádání těchto stavů a přechody mezi nimi. Pro ukázku uvádím ještě diagram této třídy na obrázku \ref{fig:GetLoginDataFlow}.

\InsertFigure{Figures/diagrams/getlogindataflow}{0.8\textwidth}{Diagram popisující vnitřní stavy stavu $getLoginData$ (GetLoginDataFlow)}{fig:GetLoginDataFlow}

Pomocí šipek jsou v diagramu popsány přechody mezi jednotlivými stavy. U každého přechodu se dále nachází informace identifikující daný přechod. Součástí této informace může být i doplňující informace o DTMF volbě, která slouží jako parametr tohoto přechodu a bývá uvedena v hranatých závorkách.

Z důvodu zpřehlednění textu zde neuvádím diagramy všech částí aplikace. Nejvíce zajímavým částem aplikace se budu detailněji věnovat později.

\subsection{Implementace hlasového portálu}
V této kapitole se budu věnovat implementaci hlasového portálu. Nejdříve se zaměřím na popis knihovny, která vznikla v rámci této práce za účelem usnadnění vývoje hlasových portálů postavených na platformě VoiceXML. Poté se vrátím k detailnějšímu popisu implementace vybraných částí hlasového portálu.

Proces implementace hlasového portálu můžu tedy rozdělit na dvě části. První částí je návrh VXML knihovny a druhou částí je návrh hlasového portálu rezervačního systému s využitím vytvořené knihovny.

\subsubsection{Implementace pomocné knihovny}

V kapitole \ref{sec:Zaklady_vxml} jsme se seznámili se základy návrhu VoiceXML dokumentů, konkrétně jsme se zde zaměřili na strukturu VXML dokumentu a popis vybraných elementů, které slouží k definici struktury aplikace. Již tedy máme dispozici znalosti, díky kterým jsme schopni napsat VXML kód, který popisuje jednoduchý hlasový portál.

Při návrhu složitějšího hlasového portálu by nám mohla ušetřit hodně práce vyšší úroveň abstrakce. Tato abstrakce by nás mohla odstínit od přímého psaní VMXL kódu. A právě tuto abstrakci zajišťuje knihovna, kterou jsem vyvinul v rámci této diplomové práce. Při použití této knihovny se nemusíme soustředit na psaní validního VXML kódu, ale veškeré naše soustředění můžeme zaměřit na aplikační logiku. Tato knihovna dále umožňuje dosáhnout efektivní znovu použitelnosti kódu formou komponentního modelu. V neposlední řadě knihovna zjednodušuje vývoj tím způsobem, že v podstatě ruší rozdělení aplikace na klientskou a serverovou část. Při vývoji aplikace tedy nemáme aplikaci striktně rozdělenou na statické VXML dokumenty, které definují strukturu aplikace a zajišťují vstup a výstup, a serverovou část, která řeší přístup k datům a implementuje aplikační logiku.

Knihovna je implementována v JavaScriptu\footnote{Více informací o této technologii můžete najít v kapitole \ref{sec:JavaScript}.} a aplikace, která je vyvíjena s využitím této knihovny je spouštěna v serverovém prostředí na platformě Node.js.

Samotná aplikace se dá jednoduše popsat jako kolekce stavů mezi kterými jsou definovány přechody do stavů dalších (v podstatě se tedy jedná o stavový automat). Každý stav může být určitého typu. Jedním typem je stav, sloužící k získání vstupu od uživatele. Dalším typem je stav, který zajišťuje výstup, tedy sděluje uživateli nějakou informaci. Posledním typem je stav, který nezajišťuje vstup ani výstup, ale implementuje pouze logiku, na základě které dochází mj. k rozhodnutí do jakého dalšího stavu se bude přecházet.

Každý stav může vyvolávat události. Pro každou vyvolanou událost je definován přechod do dalšího stavu. Způsob definice přechodů pomocí událostí zabraňuje vzniku pevných vazeb mezi objekty, které spolu potřebují nějakým způsobem komunikovat. V rámci interní implementace stavu tedy může docházet k vyvolání události, na které mohou závislé objekty nějakým způsobem reagovat.

Každý stav může definovat akci, která se vyvolá v momentě, kdy dojde ke vstupu do tohoto stavu. Stav zároveň může definovat akci, která se provede těsně před přechodem do nového stavu, tedy při opouštění stavu, který tuto akci definoval. U stavů, které slouží k získání vstupu uživatele se obsluha akce při opouštění stavu typicky využívá ke zpracování vstupních dat (např. zápis dat do databáze).

Každý stav se může skládat z dalších (vnořených) stavů. V případě, že stav vnořené stavy obsahuje, tak se mezi stavy přechází následujícím způsobem. Nejdříve se postupně navštíví vnořené stavy rodičovské stavu. Jakmile dojde k navštívení vnořeného stavu, který je finální, tak se zpracování vrací k přechodům, které má definován rodičovský stav.

Knihovna nám tedy poskytuje rozhraní API umožňující definovat jednotlivé stavy aplikace, přechody mezi těmito stavy a akce, které se mají vyvolávat při přechodech do dalších stavů. Nemusíme se tedy starat o ruční psaní VXML kódu, který je nutný pro zpracování VXML interpretrem. Tento kód generuje knihovna automaticky.

\subsubsection{Aplikační rozhraní knihovny}
V předchozí kapitole jsem představil pomocnou knihovnu a popsal jsem důvody, které mě vedly k její implementaci.

V této části se budu podrobně věnovat jednotlivým částem rozhraní API, které nám tato knihovna nabízí. Popíši zde jednotlivé třídy, které knihovna obsahuje. Aby bylo možné srovnat vývoj VXML hlasového portálu za pomoci této knihovny s tradičním způsobem vývoje (kdy ručně vytváříme VXML kód), nesmí chybět i ukázky použití jednotlivých částí knihovny.

Ve výpise \ref{src:MenuExample} je uveden zdrojový kód jednoduché aplikace, jejíž zdrojový kód nám v dalším textu poslouží pro detailnější rozbor. Jen pro představu zde ještě uvedu, co daná aplikace dělá. Aplikace představuje jednoduché menu. Nejdříve nás aplikace přivítá uvítací hláškou. Poté dojde k přechodu do menu, kde se dozvídáme, že můžeme pomocí volby DTMF zvolit hodnotu 1, 2 nebo 3. V závislosti na výběru poté přecházíme do stavu, ve kterém jsme informováni o tom, jakou volbu jsme provedli. Pokud zvolíme jinou hodnotu, než je povoleno (např. 4) dojde k přechodu do stavu, kde je nám řečeno, že jsme zvolili nepovolenou volbu.

\lstinputlisting[language=JavaScript,label=src:MenuExample,caption={Zdrojový kód ukázkové aplikace}]{Src/MenuExample.js}

\paragraph{Třída Application}
\label{sec:Application}
Každá aplikace je reprezentována hlavním objektem aplikace, který celou aplikaci zapouzdřuje. Instance této třídy představuje hlavní objekt aplikace. Hlavním úkolem aplikačního objektu je automatické generování VXML dokumentu, který je vždy vygenerován pro aktuální stav aplikace a slouží jako vstup pro VXML interpretr. Interpretr tento dokument zpracuje a výsledkem je dialog mezi uživatelem a hlasovým systémem.

Tato třída implementuje statickou metodu \texttt{create}, která přijímá potřebné parametry k vytvoření aplikace. Ve výpise \ref{src:Application_create} je uvedena ukázka kódu, kterým se vytvoří instance aplikace.

\lstinputlisting[language=JavaScript,label=src:Application_create,caption={Vytvoření hlavního objektu aplikace}]{Src/Application_create.js}

Metoda \texttt{create} přijímá jako parametr jeden objekt, který obsahuje jednotlivé parametry aplikace. Následuje popis jednotlivých parametrů.

Parametr \texttt{route} udává, na jaké URL bude aplikace dostupná.

Parametr \texttt{controller} je reference na konstruktor, který se použije k vytvoření hlavního flow\footnote{V textu používám termín $flow$ pro označení instancí třídy \texttt{CallFlow} (viz \ref{sec:CallFlow}), které definují kolekci stavů aplikace.} aplikace.

Dalším parametrem, který není povinný, je parametr \texttt{config}. Jedná se o objekt, pomocí kterého můžeme do aplikace protlačit jakékoliv další parametry. Tyto parametry jsou poté dostupné celé aplikaci. V příkladu je uvedeno nastavení \texttt{io}, kterým aplikaci předávám referenci na objekt, který se stará o generování push notifikací pomocí technologie WebSockets\footnote{Technologie WebSockets byla představena v kapitole \ref{sec:WebSockets}.}.

Hodnotou posledního parametru \texttt{server} je instance Express.js serveru (viz \ref{sec:ExpressJs}), nad kterým je VXML aplikace spuštěna. Tato instance je interně využita k navěšení metod, které obsluhují jednotlivé požadavky na přechod mezi stavy aplikace.

Aplikace běží nad HTTP protokolem. Požadavky na přechod mezi stavy jsou tedy klasické HTTP požadavky. První požadavek na VXML aplikaci má následující tvar:

\begin{quote}
\begin{sloppypar}
	\texttt{http://www.myserver.com/menu-example?session.sessionid=123}
\end{sloppypar}
\end{quote}

Následující požadavky jsou ve tvaru následujícím:

\begin{quote}
\begin{sloppypar}
	\texttt{http://www.myserver.com/menu-example?sessionid=123\allowbreak\&event=continue\&result=1}
\end{sloppypar}
\end{quote}

V URL adrese požadavku jsou zakódovány všechny potřebné informace pro provedení přechodu do dalšího stavu.

První výše uvedený požadavek obsahuje pouze jeden parametr, a tím je parametr \texttt{session.sessionid}. Tento parametr slouží jako jednoznačný identifikátor instance hovoru. Hodnotu tohoto parametru generuje IVR platforma a tuto hodnotu dále předává aplikačnímu serveru. Aplikační server tento údaj využívá jako klíč, pod kterým ukládá stav hovoru mezi jednotlivými požadavky. Informace o stavu, která je na serveru uchovávána, obsahuje například informaci o právě navštíveném stavu. Identifikátor instance hovoru je poté obsažen ve všech dalších požadavcích prostřednictvím parametru \texttt{sessionid}. Mezi dalšími požadavky je hodnota předávána prostřednictvím automaticky vygenerovaného VXML dokumentu. Pokud by hodnota nebyla přítomna, aplikace by nevěděla s jakou instancí hovoru má pracovat.

Dalším parametrem, který musí být v URL obsažen, je název události \texttt{event}, která byla vyvolána v interakci s uživatelem. Na základě této informace server zpracuje přechod do dalšího stavu.

V URL adrese požadavku může být obsažen ještě jeden parametr. Jedná se o parametr \texttt{result}. Pokud se právě zpracovává stav, který zajišťuje vstup od uživatele, pak je hodnotou tohoto parametru právě získaný vstup.

\paragraph{Třída CallFlow}
\label{sec:CallFlow}
Tato třída slouží jako bázová třída pro implementaci objektu, který představuje kontejner pro jednotlivé stavy. Primárním úkolem této třídy je vytvořit a zaregistrovat jednotlivé stavy (viz \ref{sec:State}) pomocí metody \texttt{addState}, resp. pomocí metody \texttt{addStates}, která registruje více stavů v jednom volání. Registrace stavů se provádí v metodě \texttt{create}, kterou musí každá instance implementovat.

Tento kontejner zároveň slouží jako jakási sdílená sběrnice, která je přístupná všem stavům, které jsou v kontejneru obsaženy. Může tedy např. sloužit k uchování dat, která jsou společná pro více stavů.

Důležitou metodou této třídy je metoda \texttt{fireEvent(event, data)}. Tato metoda se volá v momentě, kdy je potřeba přejít do dalšího stavu. Volání přebírá dva parametry. Parametr \texttt{event} identifikuje typ události. Na základě typu události metoda rozhodne, do jakého dalšího stavu se má přejít. Každou vyvolanou událost můžou volitelně doprovázet \texttt{data} specifická pro danou událost.

Kód ve výpise \ref{src:MenuExample} demonstruje vytvoření instance třídy \texttt{CallFlow} a registraci stavů. Takovou instanci je možné předat hlavnímu objektu aplikace prostřednictvím hodnoty parametru \texttt{controller} (viz \ref{sec:Application}).

\paragraph{Třída State}
\label{sec:State}
Tato třída reprezentuje jeden stav aplikace. Jedná se o bázovou třídu, ze které se dají odvodit specifičtější třídy nebo lze přímo vytvořit instanci této třídy. Jednotlivé stavy se registrují do instance třídy \texttt{CallFlow} např pomocí metody \texttt{addState} (viz \ref{sec:CallFlow}).

Konstruktor může přijímat tři parametry. Prvním a jediným povinným parametrem je parametr \texttt{id}. Jedná se o identifikátor stavu, který musí být jedinečný v rámci jednoho flow.

Zbývající parametry \texttt{target} a \texttt{event} jsou nepovinné. V případě, že jsou tyto parametry uvedeny, tak konstruktor interně zavolá metodu \texttt{addTransition} s hodnotami těchto parametrů. Metoda má následující předpis \texttt{addTransition(event, target, condition)}. Tato metoda slouží k definici přechodů do dalších stavů. Každý stav může mít definováno více přechodů. Přechod je definován kombinací typu události a cílového stavu. Tato kombinace může být volitelně rozšířena ještě parametrem \texttt{condition}. Metodě \texttt{addTransition} může být cílový stav \texttt{target} předán formou reference na instanci třídy \texttt{State} nebo můžeme metodě předat pouze identifikátor stavu.

V některých případech se nám může hodit nadefinovat více přechodů se stejným typem události. Více přechodů se stejným typem události bývá typicky definováno u stavů, které nějakou formou implementují menu. V momentě, kdy je proveden výběr v menu, může být vyvolána obecná událost, např. \texttt{continue}. Tato obecná událost je parametrizována hodnotou, která byla v menu zvolena. Zde se dostáváme k volitelnému parametru \texttt{condition}, který slouží k rozhodnutí, do jakého stavu se přejde. Hodnotou tohoto parametru je funkce, která přebírá jeden parametr a to je právě hodnota, která byla v menu zvolena. Tato funkce obsahuje rozhodovací logiku, která má tedy k dispozici informaci o vybrané hodnotě a vrací hodnotu \texttt{true} v případě, že se má tento přechod použít pro přechod do dalšího stavu. Demonstrace toho postupu je vidět ve výpise \ref{src:MenuExample}.

Třída dále obsahuje metody \texttt{addOnEntryAction} a \texttt{addOnExitAction}, které slouží k registraci funkcí, které se vyvolávají při vstupu, resp. při výstupu z tohoto stavu. Těchto funkcí může být pro každý typ události zaregistrováno více. V případě, že je funkcí zaregistrováno více, jsou jednotlivé funkce volány sekvenčně za sebou. Každá funkce má v momentě zavolání k dispozici reference na následující objekty. Tyto reference jsou k dispozici prostřednictvím argumentů funkce. Prvním argumentem je instance kontejneru (flow), do kterého daný stav patří. Druhým argumentem je reference na stav samotný. Poslední argument obsahuje doplňující data, která jsou závislá na konkrétním případě použití.

Jak již bylo předesláno dříve, každý stav může obsahovat vnořené stavy. K registraci vnořených stavů slouží metoda \texttt{addNestedCallFlow(callFlow)}, která přijímá jeden parametr. Hodnota parametru \texttt{callFlow} je instance, pro nás již známé, třídy \texttt{CallFlow}, která byla popsána v kapitole \ref{sec:CallFlow}. Díky této možnosti můžeme jednoduše docílit znovupoužitelnosti kódu, kdy opakovaně využívanou komponentu implementujeme jako samostatnou třídu, která je odvozena ze třídy \texttt{CallFlow}. Instance této třídy je poté registrována zavoláním metody \texttt{addNestedCallFlow} na daném stavu. V případě potřeby může být tato instance parametrizována, např. předáním různých parametrů do konstruktoru.

Třída \texttt{State} obsahuje tovární statickou metodu \texttt{create}, která je další možností, jak vytvořit instanci stavu. Oproti vytvoření stavu pomocí konstruktoru nabízí pohodlnější cestu k vytvoření stavu, který obsahuje hlasový model (viz \ref{sec:VoiceModel}). Pomocí hlasového modelu definujeme typ stavu. Jedním z typů je stav, který zajišťuje přečtení vstupu od uživatele, dalším typem stavu může být stav, který slouží k prezentaci výstupu. Vytváření stavů pomocí teto metody je použito ve výpise \ref{src:MenuExample}.

Ve stejném výpise si můžeme všimnout, že volání většiny metod třídy \texttt{State} se dá řetězit. V jednom řetězu volání můžeme vytvořit instanci stavu, navěsit akce, které se volají při přechodu do dalších stavů a nadefinovat přechody do dalších stavů.

\paragraph{Třída VoiceModel}
\label{sec:VoiceModel}
Jedná se o abstraktní třídu, ze které se instance nevytvářejí přímo. Slouží jako bázová třída, ze které jsou odvozeny třídy reprezentující konkrétní hlasový model.

Hlasový model představuje způsob, jakým definujeme typ stavu. Z tohoto pohledu knihovna rozlišuje dva typy stavů resp. hlasových modelů.

Prvním typem je hlasový model, který slouží k získání vstupu od uživatele. Takový hlasový model v praxi vypadá tak, že obsahuje text zprávy, pomocí které se uživateli sdělí, jaké jsou přípustné hodnoty pro vstup. Dále hlasový model v tomto případě obsahuje popis gramatiky, která definuje validní hodnoty pro vstup. Tento typ hlasového modelu je implementován třídou \texttt{Ask} (viz \ref{sec:Ask}).

Dalším typem hlasového modelu, který také zajišťuje získání vstupu, je hlasový model představovaný třídou \texttt{Record} (viz \ref{sec:Record}). Tento hlasový model zaznamenává vstup formou nahrávky zprávy.

Druhým typem hlasového modelu je model, který slouží k prezentaci nějakého výstupu. V praxi takový hlasový model obsahuje pouze definici zprávy, která se má uživateli sdělit. Tento typ hlasového modelu je implementován třídou \texttt{Say} (viz \ref{sec:Say}) nebo třídou \texttt{Exit} (viz \ref{sec:Exit}).

Instance tříd, které jsou z této třídy odvozeny obsahují všechny informace, které jsou nutné pro automatické vygenerování výsledného VXML souboru.

\paragraph{Třída Prompt}
\label{sec:Prompt}
Tato třída slouží k definici zprávy, která se má uživateli předložit. Tuto definici zprávy používají všechny třídy, které implementují hlasový model (viz kapitola \ref{sec:VoiceModel}).

Třída obsahuje kolekci \texttt{audios}. Tato kolekce může obsahovat jednu nebo více zpráv, které se uživateli postupně přehrají. Položkami této kolekce může být text, který bude pomocí TTS enginu převeden na hlasovou zprávu nebo reference na audio nahrávku, která bude přehrána.

Konstruktor třídy může být volán více způsoby. Ve výpise \ref{src:Prompt_Constructor} uvádím ukázky volání konstruktoru.

\lstinputlisting[language=JavaScript,label=src:Prompt_Constructor,caption={Ukázka vytvoření instance třídy \texttt{Prompt}}]{Src/Prompt_Constructor.js}

Nejjednodušší možnost vytvoření instance je ukázáno na prvním řádku výpisu. Konstrukce spočítá v předání jediného argumentu, který definuje text zprávy, který bude pomocí TTS přehrán.

Na řádku 3 je ukázána možnost vytvoření instance předáním kolekce zpráv. Kolekce v tomto případě obsahuje text a referenci na audio nahrávku (více informací o třídě \texttt{Audio} najdete k kapitole \ref{sec:Audio}).

Pokud potřebujeme vytvořit instanci a zároveň nastavit její další vlastnosti, tak můžeme využít volání konstruktoru, které je uvedeno na řádku 8. V tomto případě konstruktor přebírá jako jediný parametr objekt, který specifikuje veškerá nastavení instance.

Obě nastavení \texttt{text} a \texttt{audios} nastavují zprávu, která se uživateli předloží. V praxi nenastavujeme oba parametry, ale pouze jeden z nich. Nastavení \texttt{text} přebírá text zprávy a používá se tehdy, když definujeme pouze jednoduchou textovou zprávu. Hodnotou nastavení \texttt{audios} je kolekce zpráv, která může obsahovat textové zprávy nebo reference na audio nahrávky.

Hodnotou nastavení \texttt{bargein} definujeme, zda je možné zprávu během přehrávání přerušit např. stiskem klávesy nebo hlasovým vstupem. Výchozí hodnotou tohoto nastavení je \texttt{true}. Hodnota \texttt{true} povoluje přerušení přehrávání zprávy. Pokud chceme uživatele donutit, aby si musel zprávu vyslechnout celou, tak nastavení předáme hodnotu \texttt{false}.

Nastavením \texttt{bargeinType} blíže specifikujeme způsob, jakým je možné přehrávání zprávy přerušit. Hodnotou nastavení může být \texttt{speech} nebo \texttt{hotword}. Více informací o významu jednotlivých hodnot najdete v kapitole \ref{sec:Zaklady_vxml}.

Nastavení \texttt{language} zprostředkovává TTS enginu informaci o jazyku, v jakém má být zpráva interpretována. Pokud není hodnota specifikována, přebírá se hodnota, kterou má nastavena IVR platforma.

Nastavením \texttt{timeout} můžeme specifikovat časovou prodlevu, po kterou bude VXML interpretr čekat na uživatelovu odezvu. Hodnotou je číslo udávající tuto prodlevu ve vteřinách. Toto nastavení má smysl specifikovat v případě, kdy definujeme zprávu, která bude předcházet uživatelskému vstupu.

\paragraph{Třída Say}
\label{sec:Say}
Tato třída je odvozena ze třídy \texttt{VoiceModel} a implementuje tedy konkrétní hlasový model. Prostřednictvím tohoto hlasového modelu sdělujeme uživateli nějakou zprávu. Způsoby vytvoření instance této třídy jsou ukázány ve výpise \ref{src:Say_Constructor}.

\lstinputlisting[language=JavaScript,label=src:Say_Constructor,caption={Ukázka vytvoření instance třídy \texttt{Say}}]{Src/Say_Constructor.js}

Třída \texttt{Say} interně obsahuje instanci třídy \texttt{Prompt} a nastavuje hodnoty některým zděděným vlastnostem z třídy \texttt{VoiceModel}.

Ukázka vytvoření stavu, který obsahuje hlasový model tohoto typu, je vidět ve výpise \hyperref[src:MenuExample]{zdrojového kódu} ukázkové aplikace na řádku číslo 11.

Ve výpise \ref{src:Say_Vxml} je ukázka VXML kódu, který pro takový stav aplikace automaticky vygeneruje.

\lstinputlisting[language=XML,label=src:Say_Vxml,caption={VXML kód vygenerovaný pro stav s hlasovým modelem \texttt{Say}}]{Vxml/Say.vxml}

\paragraph{Třída Exit}
\label{sec:Exit}
Třída \texttt{Exit} implementuje hlasový model, který uživateli přehraje zprávu a poté ukončí provádění aplikace a dojde tak k zavěšení hovoru.

Nejjednodušší ukázka vytvoření instance této třídy je uvedena ve zdrojovém kódu ukázkové aplikace na řádcích 14, 17, 20 a 23. Na těchto řádcích je uveden kód, který vytváří konečné stavy aplikace. Při vstupu do takového stavu dojde k prezentaci zprávy a následnému zavěšení hovoru.

Ve výpise \ref{src:Exit_Vxml} je uvedena ukázka VXML kódu, který je pro takový stav aplikací automaticky vygenerován.

\lstinputlisting[language=XML,label=src:Exit_Vxml,caption={VXML kód vygenerovaný pro stav s hlasovým modelem \texttt{Exit}}]{Vxml/Exit.vxml}

\paragraph{Třída Record}
\label{sec:Record}
Tato třída implementuje typ hlasového modelu, který slouží k zaznamenání vstupu uživatele v podobě audio nahrávky. Uživateli je nejdříve přehrána zpráva, která ho vyzývá k zadání vstupu a poté dochází ke spuštění nahrávání. Konec nahrávání uživatel indikuje stiskem klávesy \#.

Pořízení zvukové nahrávky má v kompetenci IVR platforma a musí tedy tuto funkcionalitu podporovat. Nutno podotknout, že tuto funkcionalitu nepodporuje IVR platforma VoiceGlue.

Jelikož práce s tímto hlasovým modelem není demonstrována ve zdrojovým kódu ukázkové aplikace, tak ve výpise \ref{src:Record_example} uvádím ukázku zdrojového kódu, který vytváří stav, jehož hlasovým modelem je instance této třídy. V ukázce jsou demonstrovány dva způsoby zavolání konstruktoru.

První volání spočívá v předání jednoho argumentu. Tento argument může být textový řetězec zprávy nebo instance typu \texttt{Prompt}. Z ukázky je dále vidět způsob, jakým je možné nahrávku uložit na disk.

Druhé volání také přebírá jeden argument. Hodnotou je objekt, který obsahuje jednotlivá nastavení.

Nastavení \texttt{prompt} je zpráva, která bude uživateli předložena.

Nastavení \texttt{maxTime} nastavuje maximální délku nahrávky ve vteřinách. Výchozí hodnotou tohoto nastavení je 60 (s), tedy jedna minuta.

Nastavení \texttt{beep} udává, jestli se má po přehrání zprávy přehrát pípnutí indikující začátek proces nahrávání. Ve výchozím stavu je toto nastavení zapnuto.

Dalším nastavením je \texttt{finalSilence}. Tímto nastavením můžeme nadefinovat dobu v milisekundách, po kterou musí být uživatel vydržet tiše, aby tuto pauzu VXML interpretr vyhodnotil jako konec uživatelova vstupu a ukončil tak proces nahrávání. Výchozí hodnotou tohoto nastavení je 2500 (ms).

Posledním možným nastavením je \texttt{type}. Hodnotou tohoto nastavení udáváme MIME typ nahraného souboru. Pod tímto MIME typem bude audio nahrávka odeslána serveru\footnote{Konkrétně je hodnota MIME typu přítomna v hlavičce Content-Type požadavku.}. Výchozí hodnotou je \texttt{audio/wav}.

\lstinputlisting[language=JavaScript,label=src:Record_example,caption={Vytvoření stavu s hlasovým modelem \texttt{Record}}]{Src/Record_example.js}

Ve výpise \ref{src:Record_Vxml} je pro představu uveden VXML kód, který aplikace pro takový stav automaticky vygeneruje.

\lstinputlisting[language=XML,label=src:Record_Vxml,caption={VXML kód vygenerovaný pro stav s hlasovým modelem \texttt{Record}}]{Vxml/Record.vxml}

\paragraph{Třída Ask}
\label{sec:Ask}
Třída \texttt{Ask} prezentuje hlasový model, který slouží k zajištění vstupu od uživatele. Částečně je tato třída podobná třídě \texttt{Say}. S touto třídou má společné to, že uživateli předkládá nějakou zprávu - interně tedy také pracuje s instancí třídy \texttt{Prompt}.

Jelikož tento hlasový model zajišťuje uživatelský vstup, je potřeba mít k dispozici mechanismus, pomocí kterého bychom byli schopni popsat, jak mají hodnoty na vstupu vypadat. Třída interně využívá pro tento účel gramatiky, které byly představeny v kapitole \ref{sec:Zaklady_vxml}.

Pro účely definice těchto gramatik je využito několika tříd, kterým se budu podrobněji věnovat v dalších částech textu. Ve stručnosti zde jen uvedu, že máme k dispozici třídu \texttt{BuiltinGrammar} pro definici vestavěných gramatik, třídu \texttt{Grammar} pro definici DTMF a hlasových gramatik, a třídu \texttt{Choices}, která slouží k definici smíšených hlasových a DTMF gramatik.

Ve výpise se zdrojovým kódem ukázkové aplikace je na řádku 26 uveden kód, který vytváří stav, jehož hlasovým modelem je právě instance třídy \texttt{Ask}. Z tohoto kódu je patrné, že konstruktor třídy přijímá jeden objekt. Tento objekt musí definovat minimálně dvě povinná nastavení.

Jedno z těchto nastavení je \texttt{prompt}, které slouží k definici předkládané zprávy. Tato zpráva by měla uživatele informovat o tom, jaké jsou přípustné hodnoty pro vstup. Typem tohoto nastavení je buď řetězec nebo instance třídy \texttt{Prompt}.

Dalším povinným nastavením, které musíme při konstrukci objektu uvést, je nastavení \texttt{grammar}. Toto nastavení přebírá instanci třídy, která definuje přípustné hodnoty pro vstup.

Při vytváření instance můžeme volitelně nastavit zprávy, které se uživateli předloží v situacích, kdy nedošlo k zadání očekávaného vstupu.

Pomocí nastavení \texttt{noInputPrompts} můžeme nastavit znění zprávy, která bude uživateli přehrána v situaci, kdy nedošlo k zadání žádného vstupu.

Nastavením \texttt{noMatchPrompts} definujeme zprávu, která se uživateli přehraje v momentě, kdy byl nějaký vstup zadán, ale nesplnil pravidla na validitu vstupu popsaná gramatikou.

Obě tyto nastavení jsou typu pole a můžou tedy obsahovat více zpráv pro každý typ nastavení.

Pokud je definována jen jedna zpráva, dojde k přehrání této zprávy a následně dojde k vyvolání události \texttt{noinput}, resp. \texttt{nomatch}. Na tyto události může aplikace dále reagovat např. přechodem do chybného stavu.

Pokud je hodnotou nastavení pole více zpráv, tak zpracování funguje následovně. Po prvním neúspěšném zadání vstupu dojde k přehrání první zprávy. Poté po každém dalším špatném zadání dojde k přehrání další zprávy v pořadí. Tohoto se dá využít například k postupnému přehrávání podrobnějších informací.

Pro stav, který má jako hlasový model uvedenu instanci třídy \texttt{Ask}, aplikace automaticky vygeneruje VXML kód, který je předmětem výpisu \ref{src:Ask_Vxml}.

\lstinputlisting[language=XML,label=src:Ask_Vxml,caption={VXML kód vygenerovaný pro stav s hlasovým modelem \texttt{Ask}}]{Vxml/Ask.vxml}

\paragraph{Třída Grammar}
\label{sec:Grammar}
Prostřednictvím instancí této třídy definujeme hlasové nebo DTMF gramatiky. V podstatě se jedná o abstrakci nad VXML elementem \texttt{<grammar/>}, který byl podrobněji představen v kapitole \ref{sec:Zaklady_vxml}. Tato třída je úzce s spjata s třídou \texttt{Ask}, která tuto třídu využívá k definici přípustných vstupních dat. Pomocí této třídy lze specifikovat pouze gramatiky, které definují uživatelský vstup jako výběr jedné položky z předem definované konečné množiny.

Třída zároveň podporuje externí gramatiky, tedy gramatiky, jejichž popis se nachází v samostatném XML souboru.

Ve výpise \ref{src:Grammar_example} je vidět zdrojový kód, vytvářející stav, jehož úkolem je načíst vstup od uživatele. Povolené hodnoty vstupu jsou definovány pomocí gramatiky. V ukázce je dále vidět způsob, jakým způsobem lze programově přistoupit k zadanému vstupu.

\lstinputlisting[language=JavaScript,label=src:Grammar_example,caption={Vytvoření hlasové gramatiky}]{Src/Grammar_example.js}

Na řádcích 1 až 10 dochází k vytvoření instance gramatiky. Můžeme si všimnout, že konstruktor přebírá jeden parametr. Hodnotou tohoto parametru je objekt obsahující veškerá potřebná nastavení.

Prvním uvedeným nastavením je \texttt{mode}. Možné hodnoty nastavení jsou 'voice' nebo 'dtmf'. Tento údaj specifikuje, zda vytváříme hlasovou nebo DTMF gramatiku.

Další nastavení je \texttt{items}. Jedná se o pole položek, kde každá položka obsahuje vlastnost \texttt{text} a \texttt{tag}. Vlastnost \texttt{text} definuje text, který se bude ASR engine snažit rozeznat. Pokud dojde k úspěšnému rozeznání tohoto textu, je z gramatiky vrácena návratová hodnota. Návratová hodnota obsahuje hodnotu vlastnosti \texttt{tag}. S návratovou hodnotou lze dále pracovat. Lze ji například uložit do databáze nebo na základě této hodnoty rozvětvit program. Více položkám můžeme přiřadit stejný tag.

Definice DTMF gramatiky by vypadala analogicky. Při vytváření instance bychom pouze nastavili hodnotu nastavení \texttt{mode} na 'dtmf'. Následně bychom v definici jednotlivých položek pole \texttt{items} mohli jako hodnoty vlastnosti \texttt{text} použít pouze následující hodnoty: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, *, \#.

\paragraph{Třída BuiltinGrammar}
\label{sec:BuiltinGrammar}
Tato třída reprezentuje vestavěné gramatiky. Vestavěné gramatiky se od klasických gramatik liší způsobem, jakým jsou zapsány ve výsledném VXML kódu. Standard VXML definuje sadu vestavěných gramatik, které není v kódu potřeba nijak dále specifikovat. Stačí uvést typ gramatiky a případně její parametry. Vestavěné gramatiky byly podrobněji popsány v kapitole \ref{sec:Zaklady_vxml}.

Ve výpise \ref{src:MenuExample} je na řádcích 28-31 ukázán způsob, jakým lze vytvořit instanci této třídy.

\paragraph{Třída Choices}
\label{sec:Choices}
Tuto třídu je užitečné použít v případech, kdy chceme uživateli nabídnout možnost zadání vstupu libovolnou metodou. Uživatel může zadat vstup pomocí hlasové volby nebo pomocí DTMF volby. Na základě popisu třída interně vytvoří dvě instance třídy \texttt{Grammar}. První instance představuje hlasovou gramatiku a druhá instance představuje DTMF gramatiku.

Ve výpise \ref{src:Choices_example} se nachází zdrojový kód, který vytváří instanci kombinované gramatiky \texttt{Choices}.

\lstinputlisting[language=JavaScript,label=src:Choices_example,caption={Vytvoření kombinované gramatiky \texttt{Choices}}]{Src/Choices_example.js}

Zápis definice je hodně podobný stylu zápisu, který se používá u definice gramatik prostřednictvím třídy \texttt{Grammar}. Konstruktor třídy \texttt{Choices} přebírá jeden parametr a to je pole položek, kde každá položka obsahuje dvě vlastnosti. První vlastnost je \texttt{items} a jedná se o pole řetězců. Jednotlivé řetězce specifikují texty, které bude rozpoznávat ASR engine nebo kódy DMTF volby. Pokud chceme definovat položku jako DMTF volbu, tak ji musíme prefixovat řetězcem 'dtmf-', např. tedy 'dtmf-1'. Vlastnost \texttt{tag} specifikuje návratovou hodnotu z gramatiky.

\paragraph{Třída Audio}
\label{sec:Audio}
Prostřednictvím této třídy lze vytvářet reference na audio soubory, které se dají použít jako součást zprávy uvnitř kontejneru \texttt{Prompt}. Jedná se o abstrakci nad VXML elementem \texttt{<audio/>}. Vytvoření této instance je přímočaré. Ve výpise \ref{src:Audio_example} je uveden kód, který vytváří instanci této třídy jako součást definice zprávy.

\lstinputlisting[language=JavaScript,label=src:Audio_example,caption={Vytvoření instance \texttt{Audio}}]{Src/Audio_example.js}

Konstruktor této třídy přijímá dva parametry. Hodnotou prvního parametru je cesta k audio souboru, který se má přehrát. Hodnota druhého parametru specifikuje text, který bude přehrán pomocí TTS enginu v případě, že se nepodaří specifikovaný audio soubor stáhnout. Druhý parametr není povinný.

\paragraph{Třída Silence}
\label{sec:Silence}
Tato třída se využívá k vytvoření pauzy mezi přehrávanými částmi zprávy. Jedná se o abstrakci nad VXML elementem \texttt{<break/>}. Obsahem výpisu \ref{src:Silence_example} je ukázka zdrojového kódu, který demonstruje vytvoření krátké pauzy mezi přehrávanými částmi zprávy.

Z ukázky je patrné, že je možné délku pauzy specifikovat více způsoby. Jedním způsobem je použít jednu z definovaných textových hodnot. V tabulce \ref{tab:Silence_pauses} uvádím seznam hodnot, které lze použít. Současně s těmito hodnotami je v tabulce pro každou hodnotu uvedena přidružená délka pauzy\cite{vxml_org}.

\begin{table}
	\centering
	\begin{tabular}{|l|l|}
		\hline
		Textová hodnota & Délka pauzy [s] \\
		\hline
		none & 0 \\
		\hline
		x-weak & 0,35 \\
		\hline
		weak & 0,35 \\
		\hline
		medium & 0,7 \\
		\hline
		strong & 1 \\
		\hline
		x-strong & 1 \\
		\hline
	\end{tabular}
	\caption{Seznam textových hodnot pro definici pauzy a přidružených délek pauzy}
	\label{tab:Silence_pauses}
\end{table}

Pokud nám pro definici délky pauzy nepostačuji nadefinované hodnoty, tak můžeme pauzu vyjádřit ve vteřinách nebo v milisekundách.

Oba způsoby definice pauzy jsou znázorněny ve výpise zdrojového kódu \ref{src:Silence_example}.

\lstinputlisting[language=JavaScript,label=src:Silence_example,caption={Vytvoření instance \texttt{Silence}}]{Src/Silence_example.js}

\paragraph{Třída SayAs}
\label{sec:SayAs}
Tato třída je abstrakcí nad VXML elementem \texttt{<say-as/>}. Umožňuje nadefinovat způsob, jakým bude text interpretován TTS enginem. Tímto způsobem můžeme TTS engine instruovat například o tom, aby číslo 1234 neinterpretoval jako souvislé číslo, ale aby výsledkem byla postupná interpretace jednotlivých číslic, tedy 1, 2, 3, 4.

Ve výpise \ref{src:SayAs_example} je demonstrováno použití instance \texttt{SayAs}.

\lstinputlisting[language=JavaScript,label=src:SayAs_example,caption={Vytvoření instance \texttt{SayAs}}]{Src/SayAs_example.js}

Konstruktor přebírá dva parametry. Hodnotou prvního parametru je text, který se má interpretovat, druhý parametr udává typ interpretace. Důležité je upozornit na to, že je tato funkcionalita závislá na použitém TTS enginu a některé typy interpretací nemusí být dostupné. V následujícím seznamu uvádím typy interpretací, které by měly být podporovány TTS enginem, který je součástí IVR platformy Voxeo Prophecy\cite{vxml_org}:

\begin{itemize}
\item time
\item boolean
\item date
\item digits
\item currency
\item number
\item phone
\end{itemize}

\paragraph{Třída Var}
\label{sec:Var}
Instance této třídy slouží jako zástupné objekty pro hodnoty, které nejsou známy v době registrace stavů do kontejneru. Typicky se jedná o primitivní hodnoty, které se v JavaScriptu předávají hodnotou. Na primitivní hodnotu není možné získat referenci, a proto je potřeba takovou hodnotu zabalit do zástupného objektu.

Ve výpise \ref{src:Var_example} je demonstrována situace, kdy je použití zástupného objektu nevyhnutelné.

\lstinputlisting[language=JavaScript,label=src:Var_example,caption={Demonstrace využití zástupného objektu \texttt{Var}}]{Src/Var_example.js}

Výše uvedený kód vytváří flow aplikace, který se skládá ze dvou stavů. První stav slouží k zjištění věku uživatele. Druhý stav slouží k zobrazení sdělení o zadaném věku. A proto potřebuje hlasový model druhého stavu referencovat hodnotou vlastnosti \mbox{\texttt{this.\_age}}. Tato hodnota ale není ve fázi vytváření flow dostupná. Hodnota bude dostupná až v momentě, kdy dojde k průchodu prvním stavem. Z tohoto důvodu chybějící hodnotu zastupuje zástupný objekt reprezentovaný instancí třídy \texttt{Var} (viz řádek 18).

Konstruktor této třídy přijímá dva parametry. Hodnotou prvního parametru je kontext. Kontext představuje objekt, ze kterého se bude číst vlastnost specifikovaná druhým parametrem konstruktoru. V tomto případě je typem druhého parametru řetězec.

V některých případech může být vhodnější předat funkci jako hodnotu druhého parametru. Tato funkce může obsahovat například nějakou formátovací logiku (viz výpis \ref{src:Var_function}).

\lstinputlisting[language=JavaScript,label=src:Var_function,caption={Demonstrace využití zástupného objektu \texttt{Var}}]{Src/Var_function.js}

Třída definuje metodu \texttt{getValue}. Tato metoda je zavolána v momentě, kdy je potřeba vyhodnotit skutečnou hodnotu zástupného objektu.

Pokud byla jako druhý parametr volání konstruktoru předána funkce, tak dojde k zavolání této funkce v kontextu\footnote{V JavaScriptu může být funkce zavolána v kontextu, který může být programově nastaven na specifický objekt. Reference \texttt{this} uvnitř funkce poté ukazuje na tento nastavený objekt (kontext).}, který byl specifikován prvním argumentem. Návratová hodnota této funkce potom představuje hodnotu zástupného objektu.

Pokud byl hodnotou druhého argumentu řetězec, pak dojde k nalezení pojmenované vlastnosti v rámci specifikovaného kontextu.

\subsubsection{Popis implementace vybraných částí hlasového portálu}
V předchozí kapitole jsme získali detailní informace o struktuře a fungování navržené knihovny.

V této kapitole se opět vrátím k navrhovanému hlasovému portálu rezervačního systému a zaměřím se zde na popis vybraných komponent, které jsou nějakým způsobem zajímavé a stojí za to zmínit se o nich podrobněji.

Všechny tyto popisované komponenty jsou navrženy s ohledem na znovupoužitelnost kódu. Principu znovupoužitelnosti se dosahuje zaregistrováním instance komponenty jako sady vnořených stavů (viz kapitola \ref{sec:State}).

\paragraph{Komponenta pro zadání data}
Tato komponenta slouží k zadání data pomocí DTMF volby. V aplikaci hlasového portálu se tato komponenta používá v menu pro filtrování seznamu letů. Prostřednictvím této komponenty je uživatel vyzván k zadání požadovaného data odletu, resp. příletu. Obrázek \ref{fig:GetDateDtmfFlow} znázorňuje strukturu této komponenty formou stavového diagramu. V aplikaci je tato komponenta reprezentována třídou \texttt{GetDateDtmfFlow}.

První stav $getDate$ uživateli předkládá zprávu o tom, že se od něj očekává zadání data formou osmi číslic ve formátu $ddmmyyyy$. Prostřednictvím hodnoty parametru předané do konstruktoru je možné pro každou instanci této komponenty nastavit různý text této zprávy. Komponenta zůstává v tomto stavu, dokud nedojde k zadání vstupu v požadovaném formátu.

Pokud došlo k zadání vstupu v požadovaném formátu (8 číslic), tak zpracování přechází do druhého stavu $validateDate$. Tento stav má za úkol ověřit, zda je zadaný vstup validním datem. Ověřuje se např. zda zadaný den nepřesahuje za poslední den v daném měsíci. Toto ověření bere v úvahu přestupný rok apod.

Pokud zadaný vstup neprošel všemi validačními pravidly, dochází k vyvolání události $error$ a zpracování tak přechází do stavu $invalidDate$. Hlasový model tohoto stavu uživatele informuje o tom, že zadal neplatný vstup. Po přehrání této informace uživatel automaticky přechází do prvního stavu $getDate$, kde je vyzván k opakovanému zadání.

V případě, že došlo k zadání validního data, provede se přechod ze stavu $validateDate$ do stavu $confirmDate$. Tento stav uživateli zrekapituluje zadané datum a přechází do konečného stavu, kde životní cyklus komponenty končí.

Komponenta implementuje veřejnou metodu \texttt{getDate}. Tato metoda vrací prostřednictvím návratové hodnoty zadané datum. Metoda je typicky volána v rámci akce \texttt{onExitAction} definované na stavu, jehož je komponenta součástí.

\InsertFigure{Figures/diagrams/getdatedtmfflow}{0.8\textwidth}{Struktura komponenty pro zadání data (GetDateDtmfFlow)}{fig:GetDateDtmfFlow}

\paragraph{Komponenta pro zadání textového vstupu}
\label{sec:GetTextInputDtmfFlow}
Na obrázku \ref{fig:GetTextInputDtmfFlow} je znázorněna struktura komponenty sloužící pro získání textového vstupu pomocí DTMF volby. Vstup se zadává stejným způsobem jako se na mobilním telefonu s klávesnicí píše SMS zpráva.

Struktura komponenty je velmi jednoduchá. Skládá se pouze z jednoho stavu $askForInput$. Tento stav uživateli přehraje zprávu, prostřednictvím které uživatele vyzve k zadání textu. Text této zprávy je konfigurovatelný parametrem, který se předává konstruktoru třídy. Stav poté očekává zadání vstupu. Konec zadávání vstupu se komponentě indikuje krátkou neaktivitou nebo stisknutím klávesy #.

Zpracování vstupu probíhá ve funkci, která je zaregistrovaná pro akci \texttt{onExitAction} (viz \ref{sec:State}). Implementace této funkce spočívá v převedení vstupní číselné sekvence na textový formát. Převod se řídí mapováním, které je znázorněno v tabulce \ref{tab:GetTextInputDtmfFlow_mapping}. Např. následující sekvence 2446665 je převedena na řetězec 'ahoj'.

\begin{table}
	\centering
	\begin{tabular}{|c|l|l|l|l|l|}
		\hline
		Klávesa č. & 1. stisk & 2. stisk & 3. stisk & 4. stisk & 5. stisk \\
		\hline
		0 & $skipchar$ & - & - & - & -  \\
		\hline
		1 & \textvisiblespace & 1 & - & - & - \\
		\hline
		2 & a & b & c & 2 & - \\
		\hline
		3 & d & e & f & 3 & - \\
		\hline
		4 & g & h & i & 4 & - \\
		\hline
		5 & j & k & l & 5 & - \\
		\hline
		6 & m & n & o & 6 & - \\
		\hline
		7 & p & q & r & s & 7 \\
		\hline
		8 & t & u & v & 8 & - \\
		\hline
		9 & w & x & y & z & 9 \\
		\hline
	\end{tabular}
	\caption{Mapování stisků kláves na znaky}
	\label{tab:GetTextInputDtmfFlow_mapping}
\end{table}

V tabulce si můžeme všimnout speciálního významu klávesy 0 ($skipchar$). Tato klávesa slouží k ukončení zadávání znaku a přesunu na zadání dalšího znaku.

Stisk této klávesy není nutný v případech, kdy zadáváme dva za sebou jdoucí znaky, které jsou namapovány na stisky různých kláves.

Stisk klávesy 0 je nutný, pokud potřebujeme zadat dva po sobě jdoucí znaky, kdy každý z nich je namapován na stejnou klávesu. Pokud bychom např. potřebovali zadat textový řetězec 'abc', museli bychom ho zadat pomocí sekvence 20220222.

Třída \texttt{GetTextInputDtmfFlow} implementující tuto komponentu vystavuje veřejnou metodu \texttt{getInput}. Metoda vrací zadaný vstup převedený do textové podoby.

Tato komponenta typicky bývá součástí jiné komplexnější komponenty. Jedna taková komponenta je popsána v následujícím textu.

\InsertFigure{Figures/diagrams/gettextinputdtmfflow}{0.35\textwidth}{Struktura komponenty pro zadání textového vstupu (GetTextInputDtmfFlow)}{fig:GetTextInputDtmfFlow}

\paragraph{Komponenta pro zvolení destinace letu}
Struktura této komponenty je znázorněna v diagrumu \ref{fig:GetDestinationFlow}. Komponenta je implementována třídou \texttt{GetDestinationFlow}.

Úkolem komponenty je vyhledání destinace a následné zvolení výběru z vyhledaného seznamu. Tato komponenta je součástí filtru letů a slouží k zadání odletové, resp. příletové destinace.

Stav $getInput$ uživatele vyzve k zadání řetězce na jehož základě se provede vyhledání destinací. Tento stav obsahuje komponentu, která tento vstup zajišťuje (komponenta byla popsána v kapitole \ref{sec:GetTextInputDtmfFlow}).

V momentě, kdy máme k dispozici zadaný vstup, přechází zpracování do stavu $showInput$. V tomto stavu je uživateli přehrán text, který byl zadán. Následuje dotaz, zda zadaný vstup odpovídá tomu, co uživatel zamýšlel. Následně uživatel může zadaný vstup schválit stiskem klávesy 1 nebo odmítnout stiskem klávesy 2.

Pokud uživatel zadaný vstup odmítne, vrací se provádění do stavu $getInput$, kde má uživatel možnost provést nové zadání.

V momentě, kdy uživatel zadaný vstup potvrdí stiskem klávesy 1, přechází provádění do stavu $destinationSelection$. Tento stav obsahuje komponentu \texttt{DestinationSelectionFlow}, která tvoří vnitřní stavy tohoto stavu.

Komponenta představuje seznam vyhledaných destinací na základě vyhledávacího řetězce. Seznam vyhledaných destinací dostává komponenta k dispozici prostřednictvím reference, která je předána hodnotou parametru do konstruktoru. Struktura této komponenty je zobrazena na obrázku \ref{fig:DestinationSelectionFlow}. Z diagramu je patrné, že struktura komponenty je závislá na počtu vyhledaných destinací a může mít dvě podoby.

Pokud na základě vyhledávacího řetězce nedošlo k nalezení žádné destinace, tak komponenta obsahuje pouze jeden stav $noItems$. Tento stav, prostřednictvím svého hlasového modelu, uživateli sdělí, že žádné destinace nebyli nalezeny. Následně se provede přechod do konečného stavu, kde zpracování končí.

Pokud bylo nalezeno $n$ destinací a $n > 0$, tak dojde k vytvoření $n$ stavů. Pro každou z nalezených destinací je vytvořen jeden stav. Každý tento stav uživateli přehraje název destinace. Všechny tyto stavy jsou propojeny do řetězu, kterým je možné se pohybovat vpřed a vzad, tedy přecházet do předchozího a následujícího stavu. Tomuto řetězu předchází stav $totalItems$, který uživatele informuje o celkovém počtu nalezených destinací a o možnostech navigace mezi těmito záznamy.

Navigace je založena na DTMF volbě. K přechodu na předchozí záznam slouží klávesa 2. Pokud potřebujeme přejít k následujícímu záznamu, můžeme tak učinit stisknutím klávesy 3. Výběr aktuálního záznamu potvrzujeme stiskem klávesy 1. Stiskem této klávesy se dostáváme do stavu $selection$.

Stav $selection$ uživatele informuje o zvolené destinaci. Následuje přechod do konečného stavu, kde zpracování končí.

Komponenta implementuje metodu \texttt{getSelectedDestination}, která slouží k získání zvolené destinace. Tato metoda je typicky volána v rámci akce \texttt{onExitAction} definované na stavu, jehož je komponenta součástí.

\InsertFigure{Figures/diagrams/getdestinationflow}{1\textwidth}{Struktura komponenty pro zvolení destinace (GetDestinationFlow)}{fig:GetDestinationFlow}

\InsertFigure{Figures/diagrams/destinationselectionflow}{1\textwidth}{Vnitřní struktura stavu $destinationSelection$ komponenty pro zvolení destinace (DestinationSelectionFlow)}{fig:DestinationSelectionFlow}

\section{Konfigurace a zprovoznění hlasového portálu}
V této kapitole popíši kroky vedoucí k úspěšné konfiguraci a zprovoznění hlasového portálu na IVR platformách Voxeo Prophecy a VoiceGlue.

\subsection{Aplikační server}
\label{sec:App_server}
Abychom mohli přistoupit ke konfiguraci jednotlivých IVR platforem, musíme nejdříve nainstalovat a spustit aplikační server. Spuštěním aplikačního serveru dostaneme přístup k webovému i hlasovému portálu rezervačního systému. Následuje popis instalace a spuštění aplikačního serveru v prostředí operačního systému založeného na Linuxu.

Jak již bylo uvedeno, aplikační server je poháněn technologií Node.js (viz \ref{sec:NodeJs}). Je tedy nutné, aby na stroji byl Node.js nainstalován. Popis instalace Node.js zde popisovat nebudu, jen uvedu odkaz na oficiální web\cite{NodeJs_install}, kde je možné nalézt instalační balíky. Pří výběru instalačního balíku je nutné zvolit minimálně verzi v0.11.2. Od této verze je součástí Node.js implementace generátorů\footnote{Generátory používám v kódu VXML knihovny i aplikačního serveru pro přehlednější zpracování asynchronních operací.}, které jsou nutné pro spuštění serveru.

Další prerekvizitou je instalace MongoDB databáze. Popis instalace pro Ubuntu je detailně popsán na této URL\cite{Mongo_install}.

V momentě, kdy máme výše uvedené prerekvizity nainstalovány, můžeme přejít k instalaci modulů, na kterých je běh aplikačního serveru závislý. Otevřeme si terminál a přepneme se do adresáře, kde máme rozbalený archiv se zdrojovými kódy aplikačního serveru (TODO: přidat referenci na přílohu). Nyní můžeme spustit následující příkazy:

\begin{itemize}
\item \texttt{npm install}
\item \texttt{bower install}
\item \texttt{npm install -g grunt-cli}
\end{itemize}

První z výše uvedených příkazů instaluje moduly, na kterých je závislá serverová část aplikace (např. Express.js). Druhý příkaz se postará o instalaci knihoven, které jsou vyžadovány klientskou částí aplikace (např. Angular.js). Poslední příkaz instaluje CLI nástroje Grunt. Tento příkaz není nutné spouštět v případě, že již máte Grunt na stroji zprovozněn.

Nyní bychom měli mít nainstalováno vše, co je pro spuštění aplikačního serveru nutné. Ještě než přistoupíme k samotnému spuštění, bylo by vhodné v databázi vytvořit nějaké testovací záznamy. Spusťme proto následující příkazy:

\begin{itemize}
\item \texttt{grunt insertUsers}
\item \texttt{grunt insertFlights}
\end{itemize}

Tyto příkazy v databázi vytvoří záznamy o dvou uživatelích, dále vytvoří deset záznamů o letech.

Nyní by nám již nemělo nic bránit ve spuštění aplikačního serveru. Spuštění provedeme příkazem \texttt{grunt}. Pokud spuštění proběhlo v pořádku, tak bychom měli v terminálu vidět vypsanou informaci o tom, že aplikace byla spuštěna a naslouchá na portu 9000.

Webový portál je k dispozici na \url{http://localhost:9000/flights}. Po zadání této URL do prohlížeče by se mělo zobrazit okno pro přihlášení. Pro vyzkoušení přihlášení můžeme zkusit zadat jako přihlašovací jméno a heslo '12345'.

Hlasový portál je k dispozici na \url{http://localhost:9000/vxml}. Po zadání této URL do prohlížeče by se měla zobrazovat chyba aplikace.

\subsection{Voxeo Prophecy}
Instalace a zprovoznění této IVR platformy je jednoduché. V následující části nejdříve popíši postup instalace a poté popíši jak provést konfiguraci hlasového portálu.

\subsubsection{Instalace}
Hned na začátku je důležité poznamenat, že z linuxových distribucí, Voxeo Prophecy podporuje jen ty založené na RedHatu, např. tedy CentOS. Instalační balík stáhneme zadáním následujícího příkazu do terminálu:

\begin{quote}
\begin{sloppypar}
	\texttt{wget "http://voxeo.com/wp-content/themes/voxeo/inc/prophecy13\allowbreak\_download\_linux64\_tts\_small.php"}
\end{sloppypar}
\end{quote}

Jakmile je soubor stažen, tak si zjistíme název staženého souboru a následujícím příkazem spustíme instalaci:

\begin{quote}
	\texttt{sh prophecy-13.0.5.20.74229-x64.bin -i console}
\end{quote}

Během instalace budeme vyzváni k potvrzení několika informací. Pokud jsme na konci instalace povolili automatický start služeb, tak bychom měli mít po dokončení instalace spuštěny tři nové služby:

\begin{itemize}
\item vdirectory
\item vprism
\item vserver
\end{itemize}

Zda jsou služby spuštěny můžeme ověřit spuštěním příkazu \texttt{./prophecy status}. Tento příkaz je nutné spouštět z umístění, ve kterém máme Voxeo Prophecy nainstalované. Pokud jsme při instalaci nic neměnili, tak se jedná o umístění \texttt{/opt/voxeo/prophecy}. Pokud služby spuštěny nejsou, můžeme je spustit příkazem \texttt{./prophecy start}.

\subsubsection{Konfigurace}

\InsertFigure{Figures/Voxeo_admin}{1\textwidth}{Registrace nové VXML aplikace}{fig:Voxeo_admin}

Nyní můžeme přistoupit ke konfiguraci hlasového portálu. Součástí IVR Voxeo Prophecy je webové konfigurační rozhraní pomocí kterého konfiguraci provedeme.

Do tohoto rozhraní se dostaneme zadáním následující URL do internetového prohlížeče \url{http://localhost:9996/ManagementConsole}. Nyní bychom měli mít zobrazenu stránku s přihlašovacím formulářem. Přihlásíme se zadání řetězce 'admin', které slouží jako přihlašovací jméno i heslo. Na obrázku \ref{fig:Voxeo_admin} je zobrazena stránka, na které provedeme vytvoření nové VXML aplikace. Po přihlášení je nutné vybrat v horním menu vyznačenou ikonku (1.). Tímto se dostaneme na stránku, kde provedeme vytvoření nové aplikace. Nyní klikneme na ikonku + (2.). Tímto se nám ve spodní části stránky otevře formulář, který je nutné vyplnit.

Do pole $Name$ můžeme vyplnit jakýkoliv text. Jedná se pouze o název aplikace. Pole $Type$ specifikuje typ vytvářené aplikace, vybereme hodnotu $VXML$. Do pole $URL1$ vyplníme URL adresu, na které je spuštěn hlasový portál (viz \ref{sec:App_server}). Ve výchozím stavu je hlasový portál spuštěn na URL \url{http://localhost:9000/vxml}. Posledním krokem je vytvoření adresy aplikace. Tuto adresu je nutné vyplnit, aby bylo možné se na aplikaci dovolat. Adresu vytvoříme přidáním nového záznamu do seznamu ve spodní části formuláře. Můžeme vyplnit např. řetězec 'dp'. Zbývá vyplněné nastavení uložit. Toto provedeme stisknutím tlačítka $Save$ (3.).

Nyní by měla být naše aplikace vytvořena. Můžeme tedy provést zkušební hovor. Součástí Voxeo Prophecy je testovací SIP klient. Tento klient běží v prostředí prohlížeče a dostaneme se k němu zadáním následující URL do prohlížeče \url{http://localhost:9994/vphone/VPhoneClient/main.html}. Po zadání této URL bychom měli vidět stránku, kde máme možnost vyplnit SIP adresu naší aplikace. Zadáme tedy \texttt{sip:dp@localhost} a stiskneme tlačítko $Dial$. Pokud je vše správně nastavené, tak bychom měli za chvíli slyšet uvítací zprávu hlasového portálu.

\subsection{VoiceGlue}
V této kapitole popíši instalaci a konfiguraci opensource IVR platformy VoiceGlue. Tato platforma byla blíže představena v kapitole \ref{sec:Voxeo_interpreter}.

\subsubsection{Instalace}
Instalaci budeme provádět na stroji s operačním systémem Ubuntu Server. Něž přistoupíme k samotné instalaci IVR VoiceGlue, je třeba nainstalovat Asterisk. Vyžadována je minimálně verze 1.6. Asterisk nainstalujeme zadáním následující příkazu do terminálu:

\begin{quote}
	\texttt{sudo apt-get install asterisk}
\end{quote}

Následujícím příkazem provedeme instalaci balíků, na kterých VoiceGlue závisí:

\begin{quote}
	\texttt{sudo apt-get install libxerces-c2-dev xulrunner-dev flite curl libssl-dev libbsd-resource-perl libmodule-build-perl}
\end{quote}

Nyní se dostáváme k instalaci VoiceGlue. Prvním krokem je získání zdrojových kódu. Zdrojové kódy stáhneme zadáním příkazu:

\begin{quote}
	\texttt{wget "http://github.com/voiceglue/voiceglue/tarball/0.14"}
\end{quote}

Po stažení bychom měli mít dispozici archiv obsahující zdrojové kódy. Následující příkazy provedou rozbalení archivu, přepnutí do složky s rozbaleným obsahem archivu a spuštění instalačního skriptu:

\begin{itemize}
\item \texttt{tar -xzf 0.14}
\item \texttt{cd voiceglue-voiceglue-b12c2a2}
\item \texttt{sudo ./doc/install-voiceglue}
\end{itemize}

Pokud instalace proběhla úspěšně, měli bychom mít nainstalováné následující tři nové služby:

\begin{itemize}
\item dynlog
\item phoneglue
\item voiceglue
\end{itemize}

Pokud si přejeme, aby se tyto služby spouštěly automaticky po startu systému, můžeme tak učinit následujícím příkazem:

\begin{quote}
\begin{sloppypar}
	\texttt{for i in dynlog phoneglue voiceglue; do update-rc.d \$i defaults; done}
\end{sloppypar}
\end{quote}

Nainstalované služby zatím spouštět nebudeme.

\subsubsection{Konfigurace}
Pokud máme vše úspěšně nainstalováno, můžeme přejít ke konfiguraci. Nejdříve je nutné nakonfigurovat službu $phoneglue$. Prostřednictvím této služby probíhá komunikace mezi Asteriskem a VoiceGlue. Potřebnou konfiguraci provedeme editací souboru \texttt{/etc/asterisk/manager.conf}. Výpis \ref{src:Asterisk_manager} obsahuje kód, který je potřeba přidat na konec tohoto souboru.

\lstinputlisting[language=conf,label=src:Asterisk_manager,caption={Konfigurace souboru \texttt{/etc/asterisk/manager.conf}}]{Src/asterisk_manager.conf}

Dále je nutné se ujistit, že je v tomto souboru obsažen řádek obsahující \texttt{enabled=yes}.

Dalším krokem je vytvoření SIP účtu. Do souboru \texttt{/etc/asterisk/sip.conf} přídáme kód obsažený ve výpise \ref{src:Asterisk_sip}. Jméno uživatele a heslo si samozřejmě můžeme zvolit libovolně.

\lstinputlisting[language=conf,label=src:Asterisk_sip,caption={Konfigurace souboru \texttt{/etc/asterisk/sip.conf}}]{Src/asterisk_sip.conf}

Nyní je potřeba nakonfigurovat přepojování hovorů z Asterisku do VoiceGlue. Tuto konfiguraci provedeme v souboru \texttt{/etc/asterisk/extensions.conf}. Do souboru přidáme kód, který je obsažen ve výpise \ref{src:Asterisk_extensions}.

\lstinputlisting[language=conf,label=src:Asterisk_extensions,caption={Konfigurace souboru \texttt{/etc/asterisk/extensions.conf}}]{Src/asterisk_extensions.conf}

Kód vytváří nový kontext \texttt{[phoneglue]}. Tento kontext slouží k obsluze hovorů, které mají být zpracovány pomocí VoiceGlue. Kód dále registruje nové rozšíření představující naši hlasovou aplikaci. Adresa tohoto rozšíření je 'dp'.

Příkaz uvedený na druhém řádku provede příjem hovoru.

Třetí řádek definuje proměnnou \texttt{vxmlurl} obsahující URL adresu, na které běží náš hlasový portál. Hodnota je zakódována do takové podoby, aby ji bylo možné bezpečně přenést parametrem URL adresy.

Čtvrtý řádek definuje proměnnou \texttt{sessionid} a nastavuje její hodnotu na náhodné číslo. Hodnota této proměnné slouží jako jedinečný identifikátor hovoru (viz \ref{sec:Application}).

Pátý řádek provede prostřednictvím AGI rozhraní přepojení hovoru do subsystému VoiceGlue.

Šestý řádek provede zavěšení hovoru.

Nyní bychom měli mít vše správně nastaveno a můžeme tedy provést zkušební hovor na adresu \texttt{dp@localhost}. Hovor můžeme vytočit z jakéhokoliv SIP klienta, např. Ekiga.

\section{Zátěžové testy portálu}
\label{sec:Benchmark}
Tato kapitola je věnována zátěžovým testům hlasového portálu, jehož návrh byl popsán v předchozí kapitole. Vzhledem k licenčním omezením\footnote{Verze, která je dostupná zdarma je omezena pouze na dva porty, čili na maximálně dva souběžné hovory.}, které jsou spojeny s používáním IVR Voxeo Prophecy nebylo bohužel možné nad touto platformou zátěžové testy provést. Proto bude předmětem našich testů pouze hlasová platforma VoiceGlue.

Zátěžové testy budou spouštěny na virtuálním stroji, který je poháněn jednojádrovým procesorem o taktu 2GHz a má k dispozici 2GB operační paměti. Jako operační systém je použita serverová varianta Ubuntu 10.04.4 LTS. Na tomto stroji je nainstalována softwarová ústředna Asterisk ve verzi 1.6.2.5. Nad touto ústřednou je spuštěna hlasová platforma VoiceGlue ve verzi 0.14.

Předmětem zátěžových testů hlasového portálu je analýza výpočetní a paměťové náročnosti obsluhy různého počtu připojených klientů. V testech je měřeno celkové vytížení systému i vytíženost konkrétních procesů. Zátěžové testy jsou postaveny tak, aby bylo možné zároveň analyzovat využití hlasové platformy i aplikačního serveru. Pro tuto analýzu byly zvoleny následující procesy:

\begin{itemize}
\item asterisk
\item voiceglue
\item phoneglue
\item node
\item mongod
\end{itemize}

Analýza vytíženosti procesů $asterisk$, $voiceglue$ a $phoneglue$ nám poskytne informaci o výpočetní a paměťové náročnosti běhového prostředí hlasové platformy Z vytíženosti procesů $node$ a $mongod$ budeme zjišťovat výpočetní a paměťovou náročnost aplikačního serveru, konkrétně webového a databázového serveru.

\subsection{Scénář zátěžových testů}
Zátěžové testy spočívaly ve vytvoření zátěže na hlasovém portálu simulací $n$ připojených klientů. Každý připojený klient inicioval hovor na bázi SIP dialogu mezi hlasovým portálem. Schéma simulovaného hovoru je vyobrazeno na obrázku \ref{fig:Bench_scenario}.

Hovor sestává z následující posloupnosti akcí:

\begin{enumerate}
\item Iniciace hovoru SIP zprávou INVITE
\item Přehrání uvítací zprávy a výzvy k zadání přihl. jména
\item Zadání přihl. jména "1" prostřednictvím sekvence DTMF voleb 1 a \#
\item Přehrání výzvy k potvrzení přihl. jména
\item Potvrzení zadaného přihl. jména prostřednictvím DTMF volby 1
\item Přehrání výzvy k zadání přihl. hesla
\item Zadání přihl. hesla "1" prostřednictvím sekvence DTMF voleb 1 a \#
\item Přehrání hlavního menu
\item Zvolení "Seznamu rezervací" prostřednictvím DTMF volby 2
\item Přehrání informací o první aktivní rezervaci
\item Návrat do hlavního menu prostřednictvím DTMF volby 5
\item Přehrání hlavního menu
\item Ukončení hovoru SIP zprávou BYE
\end{enumerate}

Tento hovor byl poté spouštěn vůči hlasovému portálu. Hovory byly spouštěny v různém počtu instancí. V každém testu byl zároveň spouštěn různý počet souběžných instancí hovoru. V každém testu bylo měřeno procesorové a paměťové vytížení systému a klíčových procesů. Kapitola \ref{sec:Benchmark_results} je věnována výsledkům měření.

V tabulce \ref{tab:Benchmark_variants} jsou uvedeny všechny varianty provedených zátěžových testů.

\begin{table}
	\centering
	\begin{tabular}{|c|c|}
		\hline
		Celkový počet hovorů & Počet souběžných hovorů \\
		\hline
		5 & 5  \\
		\hline
		10 & 5  \\
		\hline
		10 & 10  \\
		\hline
		20 & 10  \\
		\hline
		20 & 20  \\
		\hline
		40 & 20  \\
		\hline
		40 & 40  \\
		\hline
		80 & 40  \\
		\hline
		60 & 60  \\
		\hline
		120 & 60  \\
		\hline
	\end{tabular}
	\caption{Varianty provedených zátěžových testů}
	\label{tab:Benchmark_variants}
\end{table}

\InsertFigure{Figures/diagrams/bench_scenario}{1\textwidth}{Schéma simulovaného hovoru}{fig:Bench_scenario}

\subsection{Použité nástroje}
Pro provedení zátěžových testů bylo potřebné zvolit vhodné nástroje. V první řadě bylo nutné použít nástroj umožnující simulaci klientů, kteří se připojují k hlasovému portálu. Dále bylo potřeba nástroje, který nám umožní měřit celkové vytížení systému a vytížení konkrétních procesů.

\subsubsection{SIPp}
SIPp je nástroj, který umožňuje generovat síťový provoz spojený se SIP protokolem. Tento nástroj umí ze XML souboru načíst definici SIP dialogu a na základě této definice generovat SIP zprávy. SIPp také umožňuje generovat pakety RTP protokolu. Podpora RTP protokolu je v testovacím scénáři využita pro přenos DTMF volby. Součástí instalace tohoto nástroje jsou k dispozici zachycené RTP pakety jednotlivých DTMF voleb ve formátu pcap.

Nástroj při spuštění přebírá několik nastavení, kterými je možné řídit např. celkový počet SIP spojení, které se mají vykonat nebo maximální počet souběžných SIP spojení.

Pro naše účely byl nástroj spouštěn např. následujícím příkazem:

\begin{quote}
\begin{sloppypar}
	\texttt{sudo sipp -sf scenario.xml -s dp -m 6 -l 2 -i 192.168.1.1 -nd -trace\_stat -fd 250 192.168.1.2}
\end{sloppypar}
\end{quote}

SIPp je nutné spouštět pomocí příkazu \texttt{sudo} a to z toho důvodu, aby program mohl vytvořit sokety, které jsou nutné pro odesílání RTP paketů.

Přepínač \texttt{sf} udává cestu k XML souboru, ve kterém je obsažena definice SIP dialogu - testovacího scénáře.

Pomocí přepínače \texttt{s} specifikujeme název vytáčené SIP služby.

Přepínačem \texttt{m} nastavujeme celkový počet vykonaných SIP spojení (hovorů).

Přepínačem \texttt{l} specifikujeme maximální počet souběžně vykonávaných SIP spojení (hovorů).

Pomocí přepínače \texttt{i} specifikujeme zdrojovou IP adresu. Tuto informaci je nutné uvést v případě, kdy stroj, na kterém SIPp běží, obsahuje více síťových rozhraní.

Uvedením přepínače \texttt{nd} vypínáme výchozí chování programu, které spočívá v ukončení běhu programu při příjmu neočekávané SIP zprávy.

Přepínač \texttt{trace\_stat} zapíná logování statistik o průběhu jednotlivých spojení.

Poslední údaj, který je nutné uvést, je IP adresa stroje, na kterém běží hlasový portál.

Tento nástroj byl pro testy zvolen hlavně proto, že umožňuje jednoduchým způsobem nasimulovat $n$ připojených klientů.

SIPp byl během zátěžových testů spouštěn na samostatném stroji, aby nedocházelo ke zvýšení vytíženosti měřeného systému vlivem běhu tohoto programu.

\subsubsection{top}
$top$ je nástroj, který je součástí UNIX-like operačních systému a slouží k monitorování aktuálně běžících procesů a podprocesů. Tento program umožňuje periodicky zjišťovat informace o celkovém využití CPU a paměti. Zároveň poskytuje informace o využití systémových prostředků aktuálně běžícími procesy v systému.

Pro účely našich zátěžových testů byl program spouštěn např. následujícím příkazem:

\begin{quote}
	\texttt{top -b -d 100 > out.txt}
\end{quote}

Přepínač \texttt{b} spouští program v dávkovém módu. Program je nutné v tomto módu spustit v případě, že chceme přesměrovat výstup do souboru.

Pomocí přepínače \texttt{d} specifikujeme dobu, po jejichž uplynutí program vygeneruje nový snímek vytíženosti systému. Ve výše uvedeném případě se tak děje každých 100ms.

Tento nástroj byl při běhu zátěžových testů spouštěn na stroji, na kterém byla spuštěna instance hlasové platformy a aplikačního serveru.

\subsubsection{Automatizační skript}
Výše jsem popsal dva nástroje, které byly využity pro simulaci připojovaných klientů a měření vytíženosti systému. Zátěžové testy byly postupně spouštěny s různými parametry. Pro zjednodušení spouštění zátěžových testů byl vytvořen $bash$ skript, kterému je možné při spouštění předat tři parametry. Ve výpise \ref{src:Benchmark_bash_script} je uveden zdrojový kód tohoto skriptu.

\lstinputlisting[language=bash,label=src:Benchmark_bash_script,caption={Zdrojový kód automatizačního skriptu \texttt{start-bench.sh}}]{Src/start-bench.sh}

Tento skript je nutné spouštět z umístění, ve kterém je obsažen XML soubor s definicí testovacího scénáře. Umístění dále musí obsahovat adresář $pcap$, ve kterém jsou uloženy soubory se zaznamenanými RTP pakety DTMF voleb. Skript je poté možné spustit např. následujícím příkazem:

\begin{quote}
	\texttt{./start-bench.sh 0.2 20 10}
\end{quote}

První parametr udává periodu vzorkování vytížení systému. Hodnota se zadává ve vteřinách. Druhý parametrem udáváme celkový počet simulovaných hovorů, které chceme vyvolat. Posledním parametrem nastavujeme maximální počet souběžných hovorů.

Skript provede po spuštění následující operace:

\begin{enumerate}
\item vytvoření adresáře pro výstupní data
\item spuštění příkazu \texttt{top} na vzdáleném stroji a přesměrování výstupu na lokální stroj
\item spuštění příkazu \texttt{sipp} na lokálním stroji
\item ukončení příkazu \texttt{top} na vzdáleném stroji
\item spuštění skriptu, který transformuje výstup příkazu \texttt{top} do formátu CSV
\item smazání dočasného souboru
\end{enumerate}

Je důležité poznamenat, že skript nezajišťuje spuštění hlasové platformy a aplikačního serveru na vzdáleném stroji. Tyto procesy je nutné spustit manuálně. Aplikační server je možné spustit následujícím příkazem:

\begin{quote}
	\texttt{PORT=9000 node --harmony index.js}
\end{quote}

Jedním z posledních operací, které skript provádí je spuštění skriptu \texttt{parse.js}. Tento skript slouží k transformaci zachyceného výstupu z programu \texttt{top} do formátu CSV, ze kterého je poté možné vygenerovat grafy. Ve zdrojovém kódu tohoto skriptu jsou nadefinována jména procesů, o nichž se mají zjišťovat informace o vytíženosti. Některé z těchto procesů mohou být spuštěny v několika instancích (samostatných procesech). Např. proces \texttt{asterisk} je obvykle spuštěn minimálně ve dvou instancích. V zachyceném výstupu z programu \texttt{top} je poté uveden zvlášť záznam o každé instanci. Skript tedy zajišťuje agregaci informace o vytíženosti dílčích procesů.

\subsection{Výsledky měření}
\label{sec:Benchmark_results}
Měřením bylo zjištěno konkrétní vytížení procesoru a využití paměti RAM při různém počtu probíhajících hovorů v kombinaci s různým počtem souběžných hovorů (viz tabulka \ref{tab:Benchmark_variants}). V této kapitole uvedu grafy zachycující zmíněné využití hlasové platformy i aplikačního serveru. Nebudu zde uvádět grafy využití všech variant zátěžových testů, ale uvedu zde jen grafy nejzajímavější variant testů (zde neuvedené grafy je možné najít v příloze).

Ve všech následně uvedených grafech je zachyceno celkové využití procesoru nebo paměti RAM včetně podílu vytíženosti jednotlivých procesů. Na osu Y jsou vynášeny procentuální hodnoty využití konkrétního zdroje - procesoru nebo paměti RAM. Osa X reprezentuje časový průběh zátěžového testu. U osy X není uvedena žádná měrná jednotka. Není uvedena z toho důvodu, že nás nezajímá vytížení v konkrétním čase, spíše nás zajímá relativní distribuce vytíženosti zdroje v průběhu testu.

\subsubsection{Zátěžový test č. 1}
Konfigurace tohoto, nejméně náročného, zátěžového testu spočívala v uskutečnění celkového počtu 5 hovorů, kdy všech 5 hovorů bylo obslouženo souběžně.

Na obrázku \ref{fig:Benchmark_CPU_5_5} je zobrazen graf zachycující využitím procesoru při této konfiguraci. Na obrázku \ref{fig:Benchmark_RAM_5_5} je vyobrazeno využití paměti RAM.

\InsertSidewaysFigure{Figures/benchmark_charts/cpu_5_5}{1\textwidth}{Využití CPU při spuštění 5 souběžných hovorů (celkově 5 hovorů)}{fig:Benchmark_CPU_5_5}
\InsertSidewaysFigure{Figures/benchmark_charts/ram_5_5}{1\textwidth}{Využití paměti RAM při spuštění 5 souběžných hovorů (celkově 5 hovorů)}{fig:Benchmark_RAM_5_5}

Z grafu vytíženosti procesoru je patrné, že celkové vytížení systému je maximální jen v určitých časových periodách, které nemají dlouhého trvání. Největší podíl na vytíženosti má proces $node$, který představuje aplikační server. Procesy, které v testu zastupují hlasovou platformu, mají téměř konstantní podíl využití. Nejvíce vytíženým procesem hlasové platformy je proces $asterisk$, tedy hlasová ústředna.

Vytíženost paměti RAM nám prozrazuje, že téměř všechny procesy mají konstantní nároky na paměť v průběhu celého testu. Nejvýraznější vyjímkou je opět proces $node$, který představuje aplikační server. Právě u tohoto procesu je patrná postupná alokace paměti.

\subsubsection{Zátěžový test č. 2}
Konfigurace tohoto zátěžového testu spočívala v uskutečnění celkového počtu 20 hovorů. V tomto případě bylo souběžně obsluhováno vždy 10 hovorů. Celková doba trvání této varianty testu tedy zabrala dvojnásobný čas.

\InsertSidewaysFigure{Figures/benchmark_charts/cpu_20_10}{1\textwidth}{Využití CPU při spuštění 10 souběžných hovorů (celkově 20 hovorů)}{fig:Benchmark_CPU_20_10}
\InsertSidewaysFigure{Figures/benchmark_charts/ram_20_10}{1\textwidth}{Využití paměti RAM při spuštění 10 souběžných hovorů (celkově 20 hovorů)}{fig:Benchmark_RAM_20_10}

Tento typ testu nám může odhalit případné problémy s uvolňováním zdrojů mezi zpracováním jednotlivých "dávek" hovorů. Z grafů \ref{fig:Benchmark_CPU_20_10} a \ref{fig:Benchmark_RAM_20_10} však není žádná kumulace využití zdrojů patrná. Můžeme tedy usoudit, že zdroje jsou vždy správně uvolňovány.

Z vytíženosti procesoru (\ref{fig:Benchmark_CPU_20_10}) je patrné, že zpracování hovorů v této konfiguraci systém stále zvládá bez sebemenšího problému - stále není ani zdaleka využit veškerý procesorový čas.

V grafu vytíženosti paměti RAM (\ref{fig:Benchmark_RAM_20_10}) si můžeme povšimnout zvýšeného podílu na využití paměti u procesu $voiceglue$. U paměťové vytíženosti ostatních procesů nedošlo k výraznějšímu nárůstu.

\subsubsection{Zátěžový test č. 3}
Konfigurace této varianty zátěžového testu spočívala v uskutečnění celkového počtu 60 hovorů, kdy všech 60 hovorů bylo obslouženo souběžně.

Využití procesoru (\ref{fig:Benchmark_CPU_60_60}) je u této varianty testu téměř stoprocentní po celou dobu trvání zátěžového testu. Je tedy patrné, že pro danou hardwarovou konfiguraci stroje (viz \ref{sec:Benchmark}) jsme se přiblížili k maximálnímu počtu hovorů, které je možné reálně obsloužit. Při větším počtu souběžných hovorů by již mohlo docházet k nepřijatelným prodlevám mezi iniciací hovoru a jeho obsloužením. Tyto prodlevy by dále mohly způsobovat problémy, které by např. mohly vést k nutnosti přeposílat některé datové pakety.

Využití paměti RAM, které můžeme vidět v grafu na obrázku \ref{fig:Benchmark_RAM_60_60}, opět ukazuje mírné zvýšení nároků na paměť u procesu $voiceglue$. U ostatních procesů není patrná žádná výrazná změna oproti výsledkům z předchozího testu.

\InsertSidewaysFigure{Figures/benchmark_charts/cpu_60_60}{1\textwidth}{Využití CPU při spuštění 60 souběžných hovorů (celkově 60 hovorů)}{fig:Benchmark_CPU_60_60}
\InsertSidewaysFigure{Figures/benchmark_charts/ram_60_60}{1\textwidth}{Využití paměti RAM při spuštění 60 souběžných hovorů (celkově 60 hovorů)}{fig:Benchmark_RAM_60_60}

\subsubsection{Obecné zhodnocení}
Výsledky jednotlivých variant zátěžových testů můžeme obecně shrnout následovně.

Měřením využití procesoru byl přibližně zjištěn maximální počet hovorů, které lze na dané hardwarové platformě obsloužit souběžně, aniž by začalo docházet k nárůstu doby potřebné pro obsloužení hovoru.

Z analýzy využití paměti RAM naopak vyplynulo, že zde existují ještě velké rezervy. Využití paměti monitorovaných procesů se nezvýšilo na nikterak vysokou hodnotu. Využití paměti jednotlivými procesy bylo téměř ve všech variantách zátěžových testů konstantní. Využití paměti bylo téměř stejné i napříč různými testy. Pouze u procesu $voiceglue$ byl mezi testy patrný mírný nárůst nároku na paměť. I přes tento mírný postupný nárůst se využití paměti tímto procesem pohybovalo pouze mezi 2-9\%.

\section{Závěr}
\label{sec:Conclusion}
Tak tady je konečně konec.

\bigskip
\begin{flushright}
Ondřej Ždych
\end{flushright}

\begin{thebibliography}{99}

\bibitem{vxmldevguide} Shukla, Charul; Dass, Avnish; Gupta, Vikas,
\textit{VoiceXML 2.0 Developer's Guide : Building Professional Voice-enabled Applications with JSP, ASP & Coldfusion}, Dream Tech Software India Inc., 2002.

\bibitem{angulardocs} Google,
\textit{Dokumentace k frameworku AngularJS}, http://docs.angularjs.org.

\bibitem{mongodb}
\textit{Web projektu MongoDB}, http://www.mongodb.org.

\bibitem{mongoose}
\textit{Web projektu Mongoose}, http://www.mongoosejs.com.

\bibitem{nodejs}
\textit{Oficiální web o Node.js}, http://www.nodejs.org.

\bibitem{expressjs}
\textit{Oficiální web o frameworku Express.js}, http://www.expressjs.com.

\bibitem{grunt}
\textit{Oficiální web věnovaný nástroji Grunt}, http://gruntjs.com.

\bibitem{vxml_org}
\textit{VXML dokumentace} Voxeo, http://www.vxml.org.

\bibitem{Mongo_install}
\textit{Popis instalace MongoDB} MongoDB, http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu.

\bibitem{NodeJs_install}
\textit{Instalační balíky Node.js} Joyent, http://nodejs.org/download.

\end{thebibliography}

\appendix
\section{Grafy a měření}
Tohle je příloha k práci. Většinou se sem dávají grafy, tabulky, které by vzhledem
ke svému počtu překážely v textu diplomky.
\clearpage

\end{document}
